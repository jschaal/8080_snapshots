=== VBA EXPORT: 8080 Model Dec.xlsm ===
Timestamp: 2/16/2026 3:24:35 PM
================================================================================

''' Component: ThisWorkbook
''' [No code]

''' Component: Sheet1
''' [No code]

''' Component: Sheet2
''' [No code]

''' Component: clsLabels
Option Explicit
'================================================================================
' Class:        clsLabels
' Purpose:      Manages assembler labels and simple "procedures" advertised on
'               the sheet so CPU code can resolve symbolic operands.
'               - ParseLabels:     builds maps of labels and address xrefs
'               - ParseProcedures: builds a set of callable procedure names
'               - GetLabel / GetByXref / AddLabel / IsProc helpers
'
' Label Types:
'   "A" = address (auto from the instruction grid)
'   "E" = EQU constant (added via EQU)
'   "D" = data row (string in OP1)
'
' Notes:        Documentation/formatting only. No functional changes.
' Source:       Stable snapshot (2026-02-12 18:38)
'================================================================================

Private pLabels As Object      ' name -> clsLabelRecord
Private pLabelXrefs As Object  ' addressHex -> clsLabelRecord
Private pProcedures As Object  ' name set for CALL proc dispatch
Private wsCPU As Worksheet

Private Sub Class_Initialize()
    Set wsCPU = ThisWorkbook.Worksheets("CPU")
    Set pLabels = CreateObject("Scripting.Dictionary")
    Set pLabelXrefs = CreateObject("Scripting.Dictionary")
    Set pProcedures = CreateObject("Scripting.Dictionary")

    ParseLabels
    ParseProcedures
End Sub

'------------------------------------------------------------------------------
' ParseLabels
' Stops after EMPTY_RUN_LIMIT consecutive rows where Label/OpCode/OP1/OP2 are all blank.
' This avoids reliance on formula-driven sentinels (e.g., "F") and makes parsing deterministic.
'------------------------------------------------------------------------------
Public Sub ParseLabels()
    Dim data As Variant
    Dim r As Long
    Dim labelRec As clsLabelRecord
    Dim line0 As Range
    Dim maxRows As Long
    Dim ofs_label As Long, ofs_opcode As Long, ofs_op1 As Long, ofs_op2 As Long, ofs_mem As Long
    Dim labelName As String, opcode As String, op1 As String, op2 As String
    Dim addrDec As Long, addrHex As String
    Dim emptyRun As Long
    Const EMPTY_RUN_LIMIT As Long = 8   ' stop after 8 consecutive empty rows

    pLabels.RemoveAll
    pLabelXrefs.RemoveAll

    Set line0 = wsCPU.Range("Line0")

    ' Offsets into the CPU grid
    ofs_label = wsCPU.Range("ofs_label").value
    ofs_opcode = wsCPU.Range("ofs_opcode").value
    ofs_op1 = wsCPU.Range("ofs_op1").value
    ofs_op2 = wsCPU.Range("ofs_op2").value
    ofs_mem = wsCPU.Range("ofs_mem").value

    ' Upper bound so we don't scan forever: MemSize + 1 is perfect
    ' (Your grid is MemStart..MemEnd; MemSize is in hex on CPU sheet.)
    maxRows = CLng(HexToDec(CStr(wsCPU.Range("MemSize").value))) + 1
    If maxRows < 1 Then maxRows = 1
    If maxRows > 5000 Then maxRows = 5000 ' hard safety cap

    ' Pull a block once for speed: from column 1 through ofs_mem
    data = line0.Offset(0, 0).Resize(maxRows, ofs_mem + 1).value

    emptyRun = 0

    For r = 1 To UBound(data, 1)

        ' Read the program fields from the array (1-based array)
        labelName = UCase$(Trim$(CStr(data(r, ofs_label + 1))))
        opcode = UCase$(Trim$(CStr(data(r, ofs_opcode + 1))))
        op1 = UCase$(Trim$(CStr(data(r, ofs_op1 + 1))))
        op2 = Trim$(CStr(data(r, ofs_op2 + 1)))

        ' Determine whether this row is "program-empty"
        If (labelName = "") And (opcode = "") And (op1 = "") And (op2 = "") Then
            emptyRun = emptyRun + 1
            If emptyRun >= EMPTY_RUN_LIMIT Then Exit For
            GoTo NextRow
        Else
            emptyRun = 0
        End If

        ' Only create a label record if there's a label text on this row
        If labelName <> "" Then

            Set labelRec = New clsLabelRecord

            ' Address is the Dec Line value at column 1 of the grid
            addrDec = CLng(data(r, 1))
            addrHex = Right$("0000" & hex$(addrDec), 4)

            labelRec.clsAddress = addrDec
            labelRec.clsAddressHex = addrHex

            ' Determine label type from opcode (no sheet calc)
            Select Case opcode
                Case "EQU"
                    labelRec.clsLabelType = "E"
                    ' EQU constant value stored in OP1 in your sheet model
                    labelRec.clsAddressHex = Right$("0000" & UCase$(op1), 4)
                    labelRec.clsAddress = HexToDec(labelRec.clsAddressHex)
                    labelRec.clsSize = IIf(labelRec.clsAddress < 256, 8, 16)

                Case "DB"
                    labelRec.clsLabelType = "D"
                    ' Data payload stored in OP1 (string)
                    labelRec.clsData = CStr(data(r, ofs_op1 + 1))
                    labelRec.clsSize = Len(labelRec.clsData)

                Case Else
                    labelRec.clsLabelType = "A"
                    labelRec.clsSize = 16
            End Select

            ' Always add by label name (including EQU)
            If Not pLabels.exists(labelName) Then
                pLabels.add labelName, labelRec
            End If

            ' Only add address xref for addressable rows (A, D)
            If (labelRec.clsLabelType = "A" Or labelRec.clsLabelType = "D") Then
                If Not pLabelXrefs.exists(addrHex) Then
                    pLabelXrefs.add addrHex, labelRec
                End If
            End If

        End If

NextRow:
    Next r
End Sub

'------------------------------------------------------------------------------
' GetLabel
' Returns the label record if found, else Nothing.
'------------------------------------------------------------------------------
Public Function GetLabel(ByVal labelName As String) As clsLabelRecord
    If pLabels.exists(labelName) Then
        Set GetLabel = pLabels(labelName)
    Else
        Set GetLabel = Nothing
    End If
End Function

'------------------------------------------------------------------------------
' AddLabel
' Adds a new label record (used by EQU). If already present, idempotent.
' Returns 0 on success, -1 on failure (empty input).
'------------------------------------------------------------------------------
Public Function AddLabel(ByVal labelName As String, ByVal LabelType As String, ByVal AddressHex As String)
    Dim labelRec As clsLabelRecord
    Dim res As Integer

    res = 0
    If labelName <> "" Then
        Set labelRec = New clsLabelRecord
        labelRec.clsAddress = HexToDec(AddressHex)
        labelRec.clsAddressHex = AddressHex

        If labelRec.clsAddress < 256 Then
            labelRec.clsSize = 8
        Else
            labelRec.clsSize = 16
        End If

        If Not pLabels.exists(labelName) And Not pLabelXrefs.exists(AddressHex) Then
            pLabels.add labelName, labelRec
            pLabelXrefs.add AddressHex, labelRec ' also allow lookup by address hex
        End If
    Else
        res = -1
    End If

    AddLabel = res
End Function

'------------------------------------------------------------------------------
' GetAddress
' Returns decimal address for a label or -1 if not found.
'------------------------------------------------------------------------------
Public Function GetAddress(ByVal labelName As String) As Long
    If pLabels.exists(labelName) Then
        GetAddress = pLabels(labelName).clsAddress
    Else
        GetAddress = -1
    End If
End Function

'------------------------------------------------------------------------------
' GetByXref
' Finds a label by its hex address string (e.g., "0108").
'------------------------------------------------------------------------------
Public Function GetByXref(ByVal address As String) As clsLabelRecord
    If pLabelXrefs.exists(address) Then
        Set GetByXref = pLabelXrefs(address)
    Else
        Set GetByXref = Nothing
    End If
End Function

'------------------------------------------------------------------------------
' ParseProcedures
' Reads the "Procedures" column on CPU sheet into a dictionary (name set).
'------------------------------------------------------------------------------
Public Sub ParseProcedures()
    Dim data As Variant
    Dim r As Long
    Dim labelRec As clsLabelRecord
    Dim lastRow As Long
    Dim labelName As String

    pProcedures.RemoveAll

    With ThisWorkbook.Sheets("CPU")
        lastRow = .Cells(.Rows.Count, .Range("Procedures").Column).End(xlUp).row
        data = .Range(.Range("Procedures"), .Cells(lastRow, .Range("Procedures").Column)).value
    End With

    For r = 1 To UBound(data, 1)
        labelName = UCase(Trim(CStr(data(r, 1))))
        If labelName <> "" Then
            Set labelRec = New clsLabelRecord
            labelRec.clsLabelType = "P" ' procedure marker
            If Not pProcedures.exists(labelName) Then
                pProcedures.add labelName, labelRec
            End If
        End If
    Next r
End Sub

'------------------------------------------------------------------------------
' IsProc
' Returns True if the name is a registered procedure (CALL shim).
'------------------------------------------------------------------------------
Public Function IsProc(ByVal labelName As String) As Boolean
    IsProc = pProcedures.exists(labelName)
End Function
'================================================================================
' Class:        clsLabels
'================================================================================


''' Component: clsLabelRecord
Option Explicit
'================================================================================
' Class:        clsLabelRecord
' Purpose:      Metadata for a label or data row.
' Fields:
'   clsLabelType  - "A" (address), "E" (EQU), "D" (data), "P" (procedure marker)
'   clsAddress    - decimal address
'   clsAddressHex - zero-padded 4-digit hex address (string)
'   clsSize       - convenience size (16 or 8 for EQU < 256; variable for "D")
'   clsData       - OP1 text for "D" data rows (used by print routines)
'================================================================================

Public clsLabelType As String
Public clsAddress As Long
Public clsAddressHex As String
Public clsSize As Integer
Public clsData As String

'================================================================================
' Class:        clsLabelRecord
'================================================================================


''' Component: Sheet4
''' [No code]

''' Component: Sheet5
''' [No code]

''' Component: TestRunner
Option Explicit
' ==============================================================================
' RunDynamicTests (DISCOVERY-BASED)
' Finds tests by scanning Column A on "Unit Tests" for any non-empty name.
' For each name, discovers the contiguous test rows starting at Hex Line = 0
' and ending at END/HLT or the first blank OpCode row, then runs/validates.
' ==============================================================================

Public Sub RunDynamicTests()
    Dim wsTest As Worksheet, wsEMU As Worksheet
    Dim memCapacity As Long
    Dim startCol As Integer, ofsOp As Integer, ofs_mem As Integer, ofs_label As Integer
    Dim endCol As Integer, colWidth As Integer
    Dim stepMode As Boolean
    Dim tests As Collection                    ' (TestName, Range, NameRow)
    Dim t As Variant
    Dim resultsCol As Long, runCol As Long
    Dim useDec As Boolean
    Dim overrideStepMode As Boolean
    Dim overrideReset As Boolean
    Dim restCPU As Boolean

    Set wsTest = Sheets("Unit Tests")
    Set wsEMU = Sheets("CPU")

    ' Pull from CPU sheet (unchanged)
    memCapacity = HexToDec(wsEMU.Range("MemSize").value)
    startCol = wsEMU.Range("ofs_label").value
    ofsOp = wsEMU.Range("ofs_opcode").value
    ofs_mem = wsEMU.Range("ofs_mem").value
    ofs_label = wsEMU.Range("ofs_label").value
    endCol = wsEMU.Range("ofs_mem").value
    colWidth = (endCol - startCol) + 1
    
'  turn off step mode and force reset for testrunner
    overrideStepMode = Range("Step") = 1
    If overrideStepMode Then
        Range("Step") = 0
    End If
    overrideReset = Range("Reset") = 0
    If overrideReset Then
        Range("Reset") = 1
    End If

    ' Honor your Run flag column again
    runCol = wsTest.Range("RunTest").Column
    resultsCol = wsTest.Range("TestRunner").Column

    'stepMode = (wsEMU.Range("Step").value = 1)
    stepMode = False
    If Not stepMode Then
        Application.ScreenUpdating = False
        Application.Calculation = xlCalculationManual
    End If

    ' Discover tests by names in Column A
    Set tests = DiscoverAllTests(wsTest)

    Dim batchPassed As Boolean: batchPassed = True
    Dim passCount As Long: passCount = 0
    Dim totalTests As Long: totalTests = 0

    For Each t In tests
        Dim testName As String: testName = CStr(t(0))
        Dim testRange As Range: Set testRange = t(1)
        Dim nameRow As Long: nameRow = CLng(t(2))

        Dim runThis As Boolean
        runThis = (Val(wsTest.Cells(nameRow, runCol).value) = 1)

        If runThis Then
            totalTests = totalTests + 1
            Application.StatusBar = "Currently Running: " & testName

            If Not testRange Is Nothing Then
                ' A) Clear emulator area
                wsEMU.Range("Line0").Offset(0, ofs_label).Resize(memCapacity + 1, ofs_mem).ClearContents
                wsEMU.Range("Line0").Offset(0, startCol).Resize(memCapacity, 1).ClearContents

                ' B) Copy program rows:
                '    Source = 5 columns starting at Label (D..H) ? Dest = 4 columns (Label..OP2)
                wsEMU.Range("Line0").Offset(0, ofs_label).Resize(testRange.Rows.Count, 4).value = _
                    testRange.Columns(3).Resize(, 5).value

    ' Clear console only if this test asserts console output
               If HasConsoleAssertions(testRange) Then
                   ClearConsole   ' clears UserForm AND ConsoleBuffer
               End If

                ' Debug breadcrumb
                'ConsolePrint "> copying " & testName & " rows=" & testRange.Rows.Count, True

                ' C) Execute
                wsEMU.Range("Reset").value = 1
                ConsolePrint ">" & testName & ":", False, False
                
                SelectEngine

                ' D) Validate
                If ValidateMultipleCriteria(testRange) Then
                    wsTest.Cells(nameRow, resultsCol).value = "PASS"
                    wsTest.Cells(nameRow, resultsCol).Interior.Color = vbGreen
                    passCount = passCount + 1
                    Call SetRunFlagInControlTable(testName, 0)
                Else
                    wsTest.Cells(nameRow, resultsCol).value = "FAIL"
                    wsTest.Cells(nameRow, resultsCol).Interior.Color = vbRed
                    batchPassed = False
                End If

                ConsolePrint wsTest.Cells(nameRow, resultsCol).value, True
                'If Not stepMode Then DoEvents
            Else
                wsTest.Cells(nameRow, resultsCol).value = "SKIPPED"
                wsTest.Cells(nameRow, resultsCol).Interior.Color = RGB(200, 200, 200)
            End If
        Else
            wsTest.Cells(nameRow, resultsCol).value = "SKIPPED"
            wsTest.Cells(nameRow, resultsCol).Interior.Color = RGB(200, 200, 200)
        End If
    Next t

    Application.Calculation = xlCalculationAutomatic
    Application.Calculate
    Application.ScreenUpdating = True
    Application.StatusBar = False
    ConsolePrint "", True
    Range("consoleText") = usrForm.tbConsole.value

'  set step and reset mode to original selectsions
    If overrideStepMode Then
        Range("Step") = 1
    End If
    If overrideReset Then
        Range("Reset") = 0
    End If

    Dim finalMsg As String
    If batchPassed Then
        finalMsg = "OVERALL RESULT: PASS" & vbCrLf & _
                   "Passed " & passCount & " of " & totalTests & " tests."
        MsgBox finalMsg, vbInformation, "Test Runner Success"
    Else
        finalMsg = "OVERALL RESULT: FAIL" & vbCrLf & _
                   "Only " & passCount & " of " & totalTests & " tests passed."
        MsgBox finalMsg, vbCritical, "Test Runner Failure"
    End If
End Sub

' ==============================================================================
' DiscoverAllTests
' Scans Column A for non-empty names. For each, calls FindTestBlock to return
' the contiguous block of test rows (B..I columns), starting where Hex Line = 0.
' Returns a Collection of Variant triplets: (TestName, Range, NameRow)
' ==============================================================================
Private Function DiscoverAllTests(ws As Worksheet) As Collection
    Dim lastRowA As Long, r As Long
    Dim tests As New Collection
    Dim testName As String
    Dim block As Range

    lastRowA = ws.Cells(ws.Rows.Count, "A").End(xlUp).row

    For r = 1 To lastRowA
        testName = Trim$(CStr(ws.Cells(r, "A").value))
        ' Only consider proper test names: Unit_* (prevents terminating on stray text)
        If Len(testName) > 0 And UCase$(testName) Like "UNIT_*" Then
            Set block = FindTestBlock(ws, r)
            Dim item As Variant
            ReDim item(0 To 2)
            item(0) = testName
            Set item(1) = block
            item(2) = r          ' row of the name for PASS/FAIL cell
            tests.add item
        End If
    Next r

    Set DiscoverAllTests = tests
End Function

' ==============================================================================
' FindTestBlock
' Given the row of a test name in Column A, locate the test rows:
'   - Find the first row below where Column B (Hex Line) is 0
'   - From there, include rows while:
'       * Column E (OpCode) is not empty, AND
'       * We haven't passed an END/HLT (inclusive – we include that row),
'     or until we hit the first blank data row.
' Builds and returns a Range spanning columns B..I for those rows.
' ==============================================================================
Private Function FindTestBlock(ws As Worksheet, nameRow As Long) As Range
    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).row
    Dim r As Long, startRow As Long, endRow As Long

    ' 1) Start at first "Hex Line = 0" below the named row (skip header lines)
    startRow = 0
    For r = nameRow + 1 To lastRow
        If Trim$(CStr(ws.Cells(r, "B").value)) = "0" Then
            startRow = r
            Exit For
        End If
        ' If another proper test name appears first, abort this one
        If Len(Trim$(CStr(ws.Cells(r, "A").value))) > 0 And _
           UCase$(Trim$(CStr(ws.Cells(r, "A").value))) Like "UNIT_*" Then
            Exit For
        End If
    Next r
    If startRow = 0 Then
        Set FindTestBlock = Nothing
        Exit Function
    End If

    ' 2) Scan forward until the next proper test name or sheet end
    '    DO NOT stop at END/HLT; include SUBs and DB data after those.
    endRow = startRow
    For r = startRow To lastRow
        If r > startRow Then
            Dim aTxt As String
            aTxt = UCase$(Trim$(CStr(ws.Cells(r, "A").value)))
            If Len(aTxt) > 0 And aTxt Like "UNIT_*" Then Exit For
        End If
        endRow = r
    Next r

    ' 3) Return B..I span (your test block columns)
    If endRow >= startRow Then
        Set FindTestBlock = ws.Range(ws.Cells(startRow, "B"), ws.Cells(endRow, "I"))
    Else
        Set FindTestBlock = Nothing
    End If
End Function

'------------------------------------------------------------------------------
' ValidateMultipleCriteria
' Each row may assert an expected register/flag or Console substring.
' "ExpectedReg" & "ExpectedVal" named ranges point to the columns in the test.
'------------------------------------------------------------------------------
Private Function ValidateMultipleCriteria(testSource As Range) As Boolean
    Dim r As Long
    Dim regName As String, expectedVal As String, actualVal As String
    Dim allPassed As Boolean: allPassed = True
    Dim useRegs As Boolean
    Dim colExpectedReg As Integer, colExpectedVal As Integer

    colExpectedReg = Range("ExpectedReg").Column - 1
    colExpectedVal = Range("ExpectedVal").Column - 1

    For r = 1 To testSource.Rows.Count
        regName = Trim(testSource.Cells(r, colExpectedReg).value)
        expectedVal = Trim(testSource.Cells(r, colExpectedVal).value)

        If regName <> "" Then
            If UCase$(regName) = "CONSOLE" Then
                allPassed = ConsoleContains(expectedVal)
            Else
                useRegs = regName Like "[ABCDEHL]"
                On Error Resume Next
                If useRegs Then
                    expectedVal = Right$("00" & expectedVal, 2)
                    actualVal = Right$("00" & Sheets("CPU").Range("R_" & regName).value, 2)
                Else
                    actualVal = Sheets("CPU").Range(regName).value
                End If
                On Error GoTo 0

                If UCase$(actualVal) <> UCase$(expectedVal) Then
                    allPassed = False
                End If
            End If
        End If

        If Not allPassed Then
            Exit For
        End If
    Next r

    ValidateMultipleCriteria = allPassed
End Function

'------------------------------------------------------------------------------
' ConsoleContains
' True if the form console contains "needle" (case-insensitive by default).
'------------------------------------------------------------------------------
Public Function ConsoleContains(ByVal needle As String, Optional ByVal caseSensitive As Boolean = False) As Boolean
    Dim txt As String
    txt = ConsoleBuffer_Text()   ' <-- authoritative, synchronous source

    If caseSensitive Then
        ConsoleContains = (InStr(1, txt, needle, vbBinaryCompare) > 0)
    Else
        ConsoleContains = (InStr(1, txt, needle, vbTextCompare) > 0)
    End If
End Function

'------------------------------------------------------------------------------
' ConsoleContainsInOrder
' True if all parts appear in the given order (not necessarily adjacent).
'------------------------------------------------------------------------------
Public Function ConsoleContainsInOrder(ParamArray parts() As Variant) As Boolean
    Dim txt As String, pos As Long, i As Long, p As String, found As Long
    txt = ConsoleBuffer_Text()   ' <-- authoritative source

    pos = 1
    For i = LBound(parts) To UBound(parts)
        p = CStr(parts(i))
        found = InStr(pos, txt, p, vbTextCompare)
        If found = 0 Then
            ConsoleContainsInOrder = False
            Exit Function
        End If
        pos = found + Len(p)
    Next i

    ConsoleContainsInOrder = True
End Function

' Returns True if the test block contains any "Console" assertions
Private Function HasConsoleAssertions(testSource As Range) As Boolean
    Dim r As Long
    Dim colExpectedReg As Integer
    
    ' Your runner already uses these named ranges; we reuse them.
    colExpectedReg = Range("ExpectedReg").Column - 1   ' Align to testSource columns

    For r = 1 To testSource.Rows.Count
        If UCase$(Trim$(CStr(testSource.Cells(r, colExpectedReg).value))) = "CONSOLE" Then
            HasConsoleAssertions = True
            Exit Function
        End If
    Next r

    HasConsoleAssertions = False
End Function
' Updates the Run column (R) in the control table P5:R… for the given TestName.
' valueToSet: 0 or 1 (we’ll use 0 on PASS as requested).
Private Sub SetRunFlagInControlTable(ByVal testName As String, ByVal valueToSet As Long)
    Dim ws As Worksheet: Set ws = Sheets("Unit Tests")
    Dim firstCell As Range: Set firstCell = ws.Range("TestTable")   ' top-left of the control table (header row)
    
    ' Find the last used row of the control table based on Column P (TestName column).
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, firstCell.Column).End(xlUp).row
    If lastRow < firstCell.row + 1 Then Exit Sub  ' no data rows

    ' Names range (Column P only)
    Dim rngNames As Range
    Set rngNames = ws.Range(firstCell.Offset(1, 0), ws.Cells(lastRow, firstCell.Column))

    ' Find TestName inside Column P (exact match, case-insensitive by Excel default)
    Dim idx As Variant
    idx = Application.Match(testName, rngNames, 0)
    If IsError(idx) Then
        ' Not found ? nothing to do (keeps tests resilient if the name isn’t listed)
        Exit Sub
    End If

    ' Compute the row for Column R (Run column): that’s P + 2 columns
    Dim targetRow As Long
    targetRow = rngNames.row + CLng(idx) - 1

    ' Set Run (Column R) to the requested value (0 on PASS)
    ws.Cells(targetRow, firstCell.Column + 2).value = valueToSet
End Sub
Public Sub ResetTestCases()
    Dim ws As Worksheet: Set ws = Sheets("Unit Tests")
    Dim firstCell As Range: Set firstCell = ws.Range("TestTable")   ' top-left of the control table (header row)
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, firstCell.Column + 1).End(xlUp).row
    If lastRow < firstCell.row + 1 Then Exit Sub  ' no data rows
    
    Dim rngNames As Range
    Set rngNames = ws.Range(firstCell.Offset(1, 0), ws.Cells(lastRow, firstCell.Column))
    Dim idx As Range
    Dim targetRow As Long
    Dim testName As String
    Application.ScreenUpdating = False
    For Each idx In rngNames
    ' Compute the row for Column R (Run column): that’s P + 2 columns
        targetRow = idx.row
        testName = ws.Cells(targetRow, firstCell.Column + 1).value
        If testName <> "" Then
            ws.Cells(targetRow, firstCell.Column + 2).value = 1
        End If
    Next idx
    Application.ScreenUpdating = True

End Sub

'================================================================================
' Module:       TestRunner
'================================================================================


''' Component: usrForm
'================================================================================
' UserForm:     usrForm (code-behind)
' Purpose:      Provides a simple "console" text box for program output.
'               - ClearConsole resets text
'               - Prt / PrtLn append text (with optional leading space)
'
' Notes:        Keeps UI responsive when CPU!Step=1 (DoEvents on write).
' Source:       Stable snapshot (2026-02-12 18:38)
'================================================================================
Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr
    
Private Const WM_VSCROLL As Long = &H115
Private Const SB_BOTTOM As Long = 7

Public Sub ClearConsole()
    Me.tbConsole.Locked = False
    Me.tbConsole.text = vbNullString
    Me.tbConsole.Locked = True
    Me.tbConsole.SelStart = 0
    Range("consoleText") = ""
    
  ' NEW: authoritative buffer clear
    ConsoleBuffer_Clear

End Sub

Public Sub ConPrtLn(ByVal data As String, Optional ByVal prtSpace As Boolean = False)
    With Me.tbConsole
        .Locked = False
        ' Append text
        .value = .value & IIf(Len(.value) > 0 And prtSpace, " ", "") & data & vbCrLf
        
        ' Force Focus and Scroll
        .SetFocus
        .SelStart = Len(.value)
        SendMessage CreateObject("WScript.Shell").SendKeys("{PGDN}"), 0, 0, 0 ' Fallback helper
        
        ' The most reliable method for MSForms:
        .CurLine = .LineCount - 1
        
        .Locked = True
    End With
    
    ' Force the UserForm to process the visual change
    Me.Repaint
    If Sheets("CPU").Range("Step").value = 1 Then DoEvents
End Sub

Public Sub ConPrt(ByVal data As String, Optional ByVal prtSpace As Boolean = False)
    With Me.tbConsole
        .Locked = False
        .value = .value & IIf(Len(.value) > 0 And prtSpace, " ", "") & data
        
        .SetFocus
        .SelStart = Len(.value)
        
        If .LineCount > 0 Then .CurLine = .LineCount - 1
        
        .Locked = True
    End With
    
     Me.Repaint
    If Sheets("CPU").Range("Step").value = 1 Then DoEvents
        
End Sub

''' Component: Exportcode
Option Explicit
'================================================================================
' Module:       Exportcode
' Purpose:      Exports all VBA components to a single timestamped .txt file and
'               saves a binary snapshot (.xlsm) to one or more output folders.
'
' Requirements:
'   - Reference: Microsoft Visual Basic for Applications Extensibility 5.3
'   - Trust Center: "Trust access to the VBA project object model" (temporarily)
'
' Notes:        Uses late binding for VBIDE objects to reduce hard dependency.
'               Documentation/formatting only. No functional changes.
' Source:       Stable snapshot (2026-02-12 18:38)
'================================================================================

Public Sub ExportAllVbaToSingleText()
    Dim vbProj As Object ' late bound VBIDE.VBProject
    Dim vbComp As Object
    Dim codeMod As Object
    Dim f, g As Integer
    Dim outputDir As Variant
    Dim baseName As String
    Dim timeStamp As String
    Dim finalFileName As String
    Dim outputPath As String
    Dim outputPathStndard As String
    Dim fullPathXlsm As String
    Dim lastLine As Long
    Dim fso As Object

    ' 1) Timestamp
    timeStamp = Format(Now, "yyyy-mm-dd_HHmm")

    ' 2) Workbook name without extension
    baseName = ThisWorkbook.name
    If InStrRev(baseName, ".") > 0 Then
        baseName = Left(baseName, InStrRev(baseName, ".") - 1)
    End If

    ' 3) Compose consistent filename
    finalFileName = baseName & "_" & timeStamp
    

    ' 4) Output destinations (array of two folders)
    Dim base As Range, saveRow As Range
    Set base = Range("Exports")
    Set fso = CreateObject("Scripting.FileSystemObject")
    For Each saveRow In base.Rows
        If saveRow.Cells(1, 1) = 1 Then
            outputDir = saveRow.Cells(1, 2)
        ' Ensure trailing backslash
            If Right(outputDir, 1) <> "\" Then outputDir = outputDir & "\"

            ' Specific file paths
            outputPath = outputDir & finalFileName & ".txt"
            fullPathXlsm = outputDir & finalFileName & ".xlsm"
            outputPathStndard = outputDir & baseName & ".txt"

            ' Ensure folder exists
            On Error Resume Next
            If Not fso.FolderExists(outputDir) Then fso.CreateFolder outputDir
            On Error GoTo 0

            ' Open the text file
            f = FreeFile
            g = FreeFile
            Open outputPath For Output As #f
            
            g = FreeFile
            Open outputPathStndard For Output As #g

            Set vbProj = ThisWorkbook.VBProject
            Print #f, "=== VBA EXPORT: " & ThisWorkbook.name & " ==="
            Print #f, "Timestamp: " & Now
            Print #f, String(80, "=")
            
            Print #g, "=== VBA EXPORT: " & ThisWorkbook.name & " ==="
            Print #g, "Timestamp: " & Now
            Print #g, String(80, "=")
    
            For Each vbComp In vbProj.VBComponents
                Set codeMod = vbComp.CodeModule
                lastLine = codeMod.CountOfLines
    
                Print #f, vbCrLf & "''' Component: " & vbComp.name
                Print #g, vbCrLf & "''' Component: " & vbComp.name
                If lastLine > 0 Then
                    Print #f, codeMod.lines(1, lastLine)
                    Print #g, codeMod.lines(1, lastLine)
                Else
                    Print #f, "''' [No code]"
                    Print #g, "''' [No code]"
                End If
            Next vbComp

            Close #f
            Close #g

            ' Binary copy of workbook
            ThisWorkbook.SaveCopyAs fullPathXlsm
        End If
    Next saveRow

    MsgBox "Export complete for: " & finalFileName, vbInformation
End Sub

'------------------------------------------------------------------------------
' ComponentTypeName (helper used by earlier versions — preserved for reference)
'------------------------------------------------------------------------------
Private Function ComponentTypeName(typeId As VBIDE.vbext_ComponentType) As String
    Select Case typeId
        Case vbext_ct_StdModule:   ComponentTypeName = "Module"
        Case vbext_ct_ClassModule: ComponentTypeName = "Class"
        Case vbext_ct_MSForm:      ComponentTypeName = "UserForm"
        Case vbext_ct_Document:    ComponentTypeName = "Document (Sheet/Workbook)"
        Case Else:                 ComponentTypeName = CStr(typeId)
    End Select
End Function

'------------------------------------------------------------------------------
' CleanFileName
' Removes extension and replaces spaces with underscores.
'------------------------------------------------------------------------------
Public Function CleanFileName(ByVal fileName As String) As String
    Dim dotPosition As Integer

    dotPosition = InStrRev(fileName, ".")
    If dotPosition > 0 Then
        fileName = Left(fileName, dotPosition - 1)
    End If

    CleanFileName = Replace(fileName, " ", "_")
End Function


''' Component: clsDecCPU
Option Explicit
'================================================================================
' Class:        clsDecCPU
' Purpose:      CPU core for the Excel/VBA Intel 8080 emulator.
'               - Register & flag storage
'               - Stack & label helpers (clsStack/clsLabels)
'               - Implemented 8080 subset (CALL, RET, LXI, MOV, MVI, INR, DCR,
'                 ORA, JMP + conditions, HLT, PUSH/POP incl. PSW)
'               - UI deferral to reduce paint during headless runs
'               - Console print shims (PRTN/PRTNS/PRTCRLF/PRTCRLFS)
'
' Notes:        Documentation/formatting only. No functional changes.
' Source:       Stable snapshot (2026-02-12 18:38)  ? Export reference.
'================================================================================

'--- State ---
Private pRegs As Object            ' Dictionary: registers A,B,C,D,E,H,L,PC,SP (hex strings)
Private pFlags As Object           ' Dictionary: Carry, Parity, AC, Zero, Sign, Flag (ints)
Private pStack As New clsDecStack
Private pLabels As New clsLabels
Private pPC_dec As Long            ' Internal PC in decimal

'--- UI deferral (headless runs) ---
Private mDeferUI As Boolean
Private mUIRegsDirty As Boolean
Private mUIFlagsDirty As Boolean
Private mUIStackDirty As Boolean

'------------------------------------------------------------------------------
' BeginDeferUI / EndDeferUI / FlushUI
' Aggregates UI writes to reduce overhead when "Step"=0.
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Class_Initialize
' Initializes registers and flags to known defaults.
'------------------------------------------------------------------------------
Private Sub Class_Initialize()
    Set pRegs = CreateObject("Scripting.Dictionary")
    pRegs.add "A", 0
    pRegs.add "B", 0
    pRegs.add "C", 0
    pRegs.add "D", 0
    pRegs.add "E", 0
    pRegs.add "H", 0
    pRegs.add "L", 0
    pRegs.add "PC", 0
    pRegs.add "SP", &HFF

    Set pFlags = CreateObject("Scripting.Dictionary")
    pFlags("Carry") = 0
    pFlags("Parity") = 0
    pFlags("AC") = 0
    pFlags("Zero") = 0
    pFlags("Sign") = 0
    pFlags("Flag") = 1
End Sub

'------------------------------------------------------------------------------
' RunOpcode
' Routes a normalized opcode to its clsCPU implementation.
' Parameters:
'   myCpu  - CPU instance
'   opcode - already UCase/Trim by Execute (kept redundant for safety)
'   op1/op2 - operands (normalized by Execute)
'   curRow  - the line's Range for context (EQU label lookup)
' Returns:
'   0 on success; negative / nonzero error codes for fault/END
'------------------------------------------------------------------------------
Public Function RunOpcode(ByVal opcode As String, _
    ByVal op1 As String, ByVal op2 As String, _
    Optional ByVal label As String = "") As Long

    Dim result As Long
    result = 0

    'opcode = Trim$(UCase$(opcode))
    Select Case opcode
        Case "ADD": result = Me.add(op1)      ' 120xx
        Case "ADI": result = Me.ADI(op1)      ' 130xx
        Case "ANA": result = Me.ANA(op1)      ' 140xx
        Case "ANI": result = Me.ANI(op1)      ' 150xx
        Case "CMP": result = Me.CMP(op1)      ' 190xx
        Case "CPI": result = Me.CPI(op1)      ' 200xx
        Case "CALL": result = Me.CALL_(op1, op2)         ' 160xx error base inside
        Case "DB":   result = 0                              ' data pseudo-op
        Case "EQU":  result = Me.EQU(op1, label)
        Case "END":  result = -200                           ' soft termination
        Case "DCR":  result = Me.DCR(op1)                 ' 230xx
        Case "HLT":  result = Me.HLT()                    ' -100
        Case "INR":  result = Me.INR(op1)                 ' 280xx
        Case "JC":   result = Me.JC(op1)
        Case "JM":   result = Me.JM(op1)
        Case "JMP":  result = Me.JMP(op1)                 ' 300xx
        Case "JNC":  result = Me.JNC(op1)
        Case "JNZ":  result = Me.JNZ(op1)
        Case "JP":   result = Me.JP(op1)
        Case "JPE":  result = Me.JPE(op1)
        Case "JPO":  result = Me.JPO(op1)
        Case "JZ":   result = Me.JZ(op1)
        Case "LXI":  result = Me.LXI(op1, op2)            ' 340xx
        Case "MOV":  result = Me.MOV(op1, op2)            ' 350xx
        Case "MVI":  result = Me.MVI(op1, op2)            ' 360xx
        Case "ORA":  result = Me.ORA(op1)                 ' 380xx
        Case "ORI":  result = Me.ORI(op1)                 ' 390xx
        Case "POP":  result = Me.POP(op1)                 ' 420xx
        Case "PUSH": result = Me.PUSH(op1)                ' 430xx
        Case "RET":  result = Me.RET()                    ' 460xx
        
        ' --- Arithmetic with carry/borrow ---
        Case "ADC": result = Me.ADC(op1)
        Case "ACI": result = Me.ACI(op1)
        Case "SUB": result = Me.SUB_(op1)
        Case "SUI": result = Me.SUI(op1)
        Case "SBB": result = Me.SBB(op1)
        Case "SBI": result = Me.SBI(op1)
        
        ' --- Logical XOR ---
        Case "XRA": result = Me.XRA(op1)
        Case "XRI": result = Me.XRI(op1)
        
        ' --- Rotates / carry ops / complement / NOP ---
        Case "RLC": result = Me.RLC()
        Case "RRC": result = Me.RRC()
        Case "RAL": result = Me.RAL()
        Case "RAR": result = Me.RAR()
        Case "STC": result = Me.STC()
        Case "CMC": result = Me.CMC()
        Case "CMA": result = Me.CMA()
        Case "NOP": result = 0
        
        ' --- 16-bit register-pair ops ---
        Case "INX": result = Me.INX(op1)
        Case "DCX": result = Me.DCX(op1)
        Case "DAD": result = Me.DAD(op1)
        Case "DAA": result = Me.DAA()
        
        ' --- Register pair exchanges / flow helpers ---
        Case "XCHG": result = Me.XCHG()
        Case "SPHL": result = Me.SPHL()
        Case "PCHL": result = Me.PCHL()
        
        ' --- Conditional CALL ---
        Case "CZ":  result = Me.CCOND("Z", op1)
        Case "CNZ": result = Me.CCOND("NZ", op1)
        Case "CC":  result = Me.CCOND("C", op1)
        Case "CNC": result = Me.CCOND("NC", op1)
        Case "CP":  result = Me.CCOND("P", op1)
        Case "CM":  result = Me.CCOND("M", op1)
        Case "CPE": result = Me.CCOND("PE", op1)
        Case "CPO": result = Me.CCOND("PO", op1)
        
        ' --- Conditional RET ---
        Case "RZ":  result = Me.RCOND("Z")
        Case "RNZ": result = Me.RCOND("NZ")
        Case "RC":  result = Me.RCOND("C")
        Case "RNC": result = Me.RCOND("NC")
        Case "RP":  result = Me.RCOND("P")
        Case "RM":  result = Me.RCOND("M")
        Case "RPE": result = Me.RCOND("PE")
        Case "RPO": result = Me.RCOND("PO")
        Case Else
            result = -9999                                   ' unrecognized opcode
    End Select

    RunOpcode = result
End Function

'==============================================================================
'                       Instruction Implementations
'==============================================================================

' ADD r
' A <- A + r ; sets S,Z,P from result; sets CY on carry out; sets AC on carry from bit 3
' Errors (base 120):
' 120: missing operand
' 121: invalid register name
Public Function add(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 120
    Dim dec_a As Long, dec_op As Long, sum As Long, result As Long
    Dim ac As Long

    If op1 = "" Then SetError errorBase, "ADD: Missing Operand": add = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "ADD: Invalid Register: " & op1: add = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = HexToDec(pRegs(op1)) And 255

    sum = dec_a + dec_op
    result = sum And 255

    ' Flags
    pFlags("Carry") = IIf(sum > 255, 1, 0)
    ac = IIf(((dec_a And &HF) + (dec_op And &HF)) > &HF, 1, 0)
    
    SetAC ac
    SetReg "A", result
    SetSign result
    SetZero result
    SetParity result
    
    add = 0
End Function
' ADI data8
' A <- A + immediate ; sets S,Z,P; sets CY and AC appropriately
' Errors (base 130):
' 130: missing operand
' 131: invalid hex immediate (or label resolves to invalid/too wide)
Public Function ADI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 130
    Dim dec_a As Long, dec_op As Long, sum As Long, result As Long
    Dim lbl As clsLabelRecord, ac As Long

    If op1 = "" Then SetError errorBase, "ADI: Missing Operand": ADI = errorBase: Exit Function

    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then op1 = lbl.clsAddressHex

    If Not IsValidHex(op1) Then SetError errorBase + 1, "ADI: Invalid Hex Immediate: " & op1: ADI = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = HexToDec(op1) And 255

    sum = dec_a + dec_op
    result = sum And 255

    pFlags("Carry") = IIf(sum > 255, 1, 0)
    ac = IIf(((dec_a And &HF) + (dec_op And &HF)) > &HF, 1, 0)
    
    SetAC ac
    SetReg "A", result
    SetSign result
    SetZero result
    SetParity result
    
    ADI = 0
End Function
' ANA r
' A <- A AND r ; clears CY; (8080) sets AC=1; sets S,Z,P
' Errors (base 140):
' 140: missing operand
' 141: invalid register
Public Function ANA(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 140
    Dim dec_a As Long, dec_op As Long, result As Long

    If op1 = "" Then SetError errorBase, "ANA: Missing Operand": ANA = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "ANA: Invalid Register: " & op1: ANA = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = pRegs(op1) And 255
    result = (dec_a And dec_op) And 255

    SetReg "A", result
    SetCarry 0
    SetAC 1                     ' 8080 convention for AND
    SetSign result
    SetZero result
    SetParity result
    
    ANA = 0
End Function
' ANI data8
' A <- A AND immediate ; clears CY; sets AC=1; sets S,Z,P
' Errors (base 150):
' 150: missing operand
' 151: invalid hex immediate
Public Function ANI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 150
    Dim dec_a As Long, dec_op As Long, result As Long
    Dim lbl As clsLabelRecord

    If op1 = "" Then SetError errorBase, "ANI: Missing Operand": ANI = errorBase: Exit Function

    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then op1 = lbl.clsAddressHex
    If Not IsValidHex(op1) Then SetError errorBase + 1, "ANI: Invalid Hex Immediate: " & op1: ANI = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = HexToDec(op1) And 255
    result = (dec_a And dec_op) And 255

    SetReg "A", result
    SetCarry 0
    SetAC 1
    SetSign result
    SetZero result
    SetParity result
    
    ANI = 0
End Function
' CMP r
' Compare A with r: (A - r) sets S,Z,P; sets CY=1 on borrow; sets AC on borrow from bit3; A unchanged
' Errors (base 190):
' 190: missing operand
' 191: invalid register
Public Function CMP(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 190
    Dim dec_a As Long, dec_op As Long, diff As Long
    Dim borrow As Long, acBorrow As Long, result As Long

    If op1 = "" Then SetError errorBase, "CMP: Missing Operand": CMP = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "CMP: Invalid Register: " & op1: CMP = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = HexToDec(pRegs(op1)) And 255

    borrow = IIf(dec_a < dec_op, 1, 0)
    acBorrow = IIf((dec_a And &HF) < (dec_op And &HF), 1, 0)

    diff = dec_a - dec_op
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow
    SetSign result
    SetZero result
    SetParity result
    
    CMP = 0
End Function
' CPI data8
' Compare A with immediate: (A - data) sets S,Z,P; CY=1 on borrow; AC as nibble borrow; A unchanged
' Errors (base 200):
' 200: missing operand
' 201: invalid hex immediate
Public Function CPI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 200
    Dim dec_a As Long, dec_op As Long, diff As Long, result As Long
    Dim lbl As clsLabelRecord, borrow As Long, acBorrow As Long

    If op1 = "" Then SetError errorBase, "CPI: Missing Operand": CPI = errorBase: Exit Function

    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then op1 = lbl.clsAddressHex
    If Not IsValidHex(op1) Then SetError errorBase + 1, "CPI: Invalid Hex Immediate: " & op1: CPI = errorBase + 1: Exit Function

    dec_a = pRegs("A") And 255
    dec_op = HexToDec(op1) And 255

    borrow = IIf(dec_a < dec_op, 1, 0)
    acBorrow = IIf((dec_a And &HF) < (dec_op And &HF), 1, 0)

    diff = dec_a - dec_op
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow
    SetSign result
    SetZero result
    SetParity result
    
    CPI = 0
End Function
'------------------------------------------------------------------------------
' CALL_
' CALL Label | CALL ProcName
' If the operand is a known Procedure (clsLabels.IsProc), dispatches to that
' method via CallByName; otherwise pushes return address and jumps to label.
' Errors (base 160):
'   160: missing operand
'   161: label not found
'------------------------------------------------------------------------------
Public Function CALL_(ByVal op1 As String, Optional ByVal op2 As String = "") As Long
    Dim record As clsLabelRecord, currentPC As Long, retAddr As Long
    Dim strAddr As String, sp_dec As Long, proc As Boolean
    Dim line0Address As Long
    Dim errorBase As Long: errorBase = 160

    If op1 = "" Then
        SetError errorBase, "CALL: Missing Operand: " & op1
        CALL_ = errorBase: Exit Function
    End If

    proc = pLabels.IsProc(op1)
    If proc Then
        CALL_ = CallByName(Me, op1, VbMethod, op2)
        Exit Function
    End If

    Set record = pLabels.GetLabel(op1)
    If record Is Nothing Then
        SetError errorBase + 1, "CALL: Missing Label: " & op1
        CALL_ = errorBase + 1: Exit Function
    End If

    currentPC = pPC_dec
    sp_dec = pRegs("SP")
    retAddr = currentPC + 1

    strAddr = Right$("0000" & FastHex(retAddr), 4)

    sp_dec = sp_dec - 1
    pStack.clsPUSH sp_dec, HexToDec(Left$(strAddr, 2)), "CALL " & op1
    sp_dec = sp_dec - 1
    pStack.clsPUSH sp_dec, HexToDec(Right$(strAddr, 2)), "CALL " & op1
    
    SetReg "SP", sp_dec
    mUIStackDirty = True
    
    pPC_dec = record.clsAddress - 1
    SetPC pPC_dec
    
    CALL_ = 0
End Function

'------------------------------------------------------------------------------
' CLS (console clear)
'------------------------------------------------------------------------------
Public Function CLS(Optional ByVal op1 = "", Optional ByVal op2 = "") As Long
    usrForm.ClearConsole
    CLS = 0
End Function

'------------------------------------------------------------------------------
' DCR r
' Decrement register (affects Z,S,P,AC; not Carry)
' Errors (base 230):
'   230: missing operand
'   231: invalid register name
'------------------------------------------------------------------------------
Public Function DCR(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 230
    Dim result As Long, current As Long, ac As Long

    If op1 = "" Then SetError errorBase, "DCR: Missing Operands: " & op1: DCR = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "DCR: Invalid Register: " & op1: DCR = errorBase + 1: Exit Function

    current = pRegs(op1)
    result = (current - 1) And 255

    ' Auxiliary carry is set on borrow from bit 4 (i.e., when low nibble goes from 0 -> F)
    ac = IIf((current And &HF) = 0, 1, 0)
    SetAC ac
    SetZero result
    SetSign result
    SetParity result
    SetReg op1, result

    DCR = 0
End Function

'------------------------------------------------------------------------------
' EQU value, <LabelFromSheet>
' Binds a label to a constant hex value (sheet-provided label name).
' Errors (base 300):
'   300: missing value
'   301: missing label name
'   302: duplicate label
'   303: invalid hex value
'   EQU labels are now loaded in parselabels and not set individually
'------------------------------------------------------------------------------
Public Function EQU(ByVal op1 As String, label As String) As Long
    Dim errorBase As Long: errorBase = 300
    Dim res As Long
    Dim record As clsLabelRecord

    If op1 = "" Then SetError errorBase, "EQU: Missing Operand: " & op1: EQU = errorBase: Exit Function
    If label = "" Then SetError errorBase + 1, "EQU: Missing Label: " & label: EQU = errorBase + 1: Exit Function

    Set record = pLabels.GetLabel(label)
    If record Is Nothing Then SetError errorBase + 2, "EQU: Missing label: " & label: EQU = errorBase + 2: Exit Function

    If Not IsValidHex(op1) Then SetError errorBase + 3, "EQU: Invalid Valid: " & op1: EQU = errorBase + 3: Exit Function
    EQU = 0
End Function

'------------------------------------------------------------------------------
' HLT
'------------------------------------------------------------------------------
Public Function HLT() As Long
    Dim errorBase As Long: errorBase = -100
    SetError errorBase, "Program Halted:"
    HLT = errorBase
End Function

'------------------------------------------------------------------------------
' INR r
' Increment register (affects Z,S,P,AC; not Carry)
' Errors (base 280):
'   280: missing operand
'   281: invalid register
'------------------------------------------------------------------------------
Public Function INR(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 280
    Dim result As Long, current As Long, nibble As Long, ac As Long

    If op1 = "" Then SetError errorBase, "INR: Missing Operands: " & op1: INR = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "INR: Invalid Register: " & op1: INR = errorBase + 1: Exit Function

    current = pRegs(op1)
    result = (current + 1) And 255

    nibble = current And 15
    ac = IIf(nibble = 15, 1, 0)
    SetAC ac
    SetZero result
    SetSign result
    SetParity result
    SetReg op1, result
    
INR = 0
End Function

'------------------------------------------------------------------------------
' JMP label
' Jump to label (valid range enforced by MemEnd).
' Errors (base 300):
'   300: missing operand
'   301: label not found
'   302: label resolves to invalid hex
'   303: out-of-range address
'------------------------------------------------------------------------------
Public Function JMP(op1 As String) As Long
    Dim errorBase As Long: errorBase = 300
    Dim memEnd_dec As Long, op_dec As Long
    Dim record As clsLabelRecord
    Dim line0Address As Long

    If op1 = "" Then SetError errorBase, "JMP: Missing Operand: " & op1: JMP = errorBase: Exit Function

    Set record = pLabels.GetLabel(op1)
    If record Is Nothing Then SetError errorBase + 1, "JMP: Missing Label: " & op1: JMP = errorBase + 1: Exit Function

    op1 = record.clsAddressHex
    If Not IsValidHex(op1) Then SetError errorBase + 2, "JMP: Invalid Operand: " & op1: JMP = errorBase + 2: Exit Function

    memEnd_dec = Range("MemEnd").Offset(0, 1).value
    op_dec = HexToDec(op1)
    If op_dec < 0 Or op_dec > memEnd_dec Then SetError errorBase + 3, "JMP: Invalid Address: " & op1: JMP = errorBase + 3: Exit Function

    SetPC op_dec - 1

    JMP = 0
End Function

' Conditional jumps are thin wrappers over EvaluateCondition + JMP
Public Function JZ(ByVal op1 As String) As Long
    If EvaluateCondition("JZ") Then
        JZ = JMP(op1)
    Else
        JZ = 0
    End If
End Function

Public Function JNZ(ByVal op1 As String) As Long
    If EvaluateCondition("JNZ") Then
        JNZ = JMP(op1)
    Else
        JNZ = 0
    End If
End Function

Public Function JC(ByVal op1 As String) As Long
    If EvaluateCondition("JC") Then
        JC = JMP(op1)
    Else
        JC = 0
    End If
End Function

Public Function JNC(ByVal op1 As String) As Long
    If EvaluateCondition("JNC") Then
        JNC = JMP(op1)
    Else
        JNC = 0
    End If
End Function

Public Function JM(ByVal op1 As String) As Long
    If EvaluateCondition("JM") Then
        JM = JMP(op1)
    Else
        JM = 0
    End If
End Function

Public Function JP(ByVal op1 As String) As Long
    If EvaluateCondition("JP") Then
        JP = JMP(op1)
    Else
        JP = 0
    End If
End Function

Public Function JPE(ByVal op1 As String) As Long
    If EvaluateCondition("JPE") Then
        JPE = JMP(op1)
    Else
        JPE = 0
    End If
End Function

Public Function JPO(ByVal op1 As String) As Long
    If EvaluateCondition("JPO") Then
        JPO = JMP(op1)
    Else
        JPO = 0
    End If
End Function

'------------------------------------------------------------------------------
' LXI rp, addr|label
' Loads 16-bit immediate into B/D/H or SP (SP also paints stack start).
' Errors (base 340):
'   340: missing operands
'   341: invalid register pair (must be B,D,H,SP)
'   342: invalid address (or unresolved label to invalid)
'------------------------------------------------------------------------------
Public Function LXI(ByVal op1 As String, op2 As String) As Long
    Dim errorBase As Long: errorBase = 340
    Dim record As clsLabelRecord
    Dim useLabel As Boolean
    Dim address As String
    Dim regLow As String, regHigh As String
    Dim decLow As Long, decHigh As Long
    Dim ofs_mem As Long, sp As Long, memStart As Long

    If op1 = "" Or op2 = "" Then SetError errorBase, "LXI: Missing Operands: " & op1 & " " & op2: LXI = errorBase: Exit Function
    If op1 <> "B" And op1 <> "D" And op1 <> "H" And op1 <> "SP" Then SetError errorBase + 1, "LXI: Invalid Register: " & op1: LXI = errorBase + 1: Exit Function

    Set record = pLabels.GetLabel(op2)
    useLabel = Not record Is Nothing
    If useLabel Then op2 = record.clsAddressHex

    If Not IsValidHex(op2) Then SetError errorBase + 2, "LXI: Invalid Address: " & op2: LXI = errorBase + 2: Exit Function

    address = Right$("0000" & op2, 4)
    regHigh = Left$(address, 2)
    regLow = Right$(address, 2)
    decLow = HexToDec(regLow)
    decHigh = HexToDec(regHigh)

    Select Case op1
        Case "B": SetReg "B", decHigh: SetReg "C", decLow
        Case "D": SetReg "D", decHigh: SetReg "E", decLow
        Case "H": SetReg "H", decHigh: SetReg "L", decLow
        Case "SP"
            Me.SetReg "SP", HexToDec(address)
            mUIStackDirty = True

    End Select
    
    LXI = 0
End Function

'------------------------------------------------------------------------------
' MOV r1, r2
' Errors (base 350):
'   350: missing operands
'   351: invalid register(s)
'------------------------------------------------------------------------------
Public Function MOV(ByVal op1 As String, ByVal op2 As String) As Long
    Dim errorBase As Long: errorBase = 350
    If op1 = "" Or op2 = "" Then SetError errorBase, "MOV: Missing Operands: " & op1 & " " & op2: MOV = errorBase: Exit Function

    If pRegs.exists(op1) And pRegs.exists(op2) Then
        SetReg op1, pRegs(op2)
    Else
        SetError errorBase + 1, "MOV: Invalid Registers: " & op1 & " " & op2: MOV = errorBase + 1: Exit Function
    End If
    MOV = 0
End Function

'------------------------------------------------------------------------------
' MVI r, data|label
' Errors (base 360):
'   360: missing operands
'   361: invalid hex value
'   362: invalid register
'------------------------------------------------------------------------------
Public Function MVI(ByVal op1 As String, ByVal op2 As String) As Long
    Dim errorBase As Long: errorBase = 360
    Dim labelRecord As clsLabelRecord

    If op1 = "" Or op2 = "" Then SetError errorBase, "MVI: Missing Operands: " & op1 & " " & op2: MVI = errorBase: Exit Function

    Set labelRecord = pLabels.GetLabel(op2)
    If Not labelRecord Is Nothing Then op2 = labelRecord.clsAddressHex

    If Not IsValidHex(op2) Then SetError errorBase + 1, "MVI: Invalid Hex Value: " & op2: MVI = errorBase + 1: Exit Function
    If pRegs.exists(op1) Then
        SetReg op1, HexToDec(op2)
    Else
        SetError errorBase + 2, "MVI: Invalid Register: " & op1: MVI = errorBase + 2: Exit Function
    End If
    
    MVI = 0
End Function

'------------------------------------------------------------------------------
' ORA r
' Logical OR A <- A OR r; clears Carry and AC; sets S,Z,P
' Errors (base 380):
'   380: missing operand
'------------------------------------------------------------------------------
Public Function ORA(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 380
    Dim result As Long
    Dim dec_op1 As Long, dec_a As Long

    If op1 = "" Then SetError errorBase, "ORA: Missing Operand: " & op1: ORA = errorBase: Exit Function

    dec_op1 = pRegs(op1)
    dec_a = pRegs("A")
    result = (dec_a Or dec_op1) And 255

    SetReg "A", result
    SetCarry 0
    SetAC 0
    SetSign result
    SetZero result
    SetParity result
    
    ORA = 0
End Function
' ORI data
' A <- A OR immediate; clears CY and AC; sets S,Z,P
' Errors (base 390):
' 390: missing operand
' 391: invalid hex immediate (or label resolves to invalid/too wide)
Public Function ORI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 390
    Dim result As Long
    Dim dec_op1 As Long, dec_a As Long
    Dim lbl As clsLabelRecord
    
    ' 1) Operand required
    If op1 = "" Then
        SetError errorBase, "ORI: Missing Operand"
        ORI = errorBase
        Exit Function
    End If

    ' 2) Allow EQU labels as immediate (like your MVI does)
    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then
        op1 = lbl.clsAddressHex  ' use the label's hex value/address
    End If

    ' 3) Validate immediate (8-bit)
    If Not IsValidHex(op1) Then
        SetError errorBase + 1, "ORI: Invalid Hex Immediate: " & op1
        ORI = errorBase + 1
        Exit Function
    End If
    dec_op1 = HexToDec(op1) And 255  ' force to 8-bit

    ' 4) Compute result
    dec_a = pRegs("A") And 255
    result = (dec_a Or dec_op1) And 255

    ' 5) Write A and flags (CY/AC cleared; S/Z/P from result)
    SetReg "A", result
    SetCarry 0
    SetAC 0
    SetSign result
    SetZero result
    SetParity result


    ORI = 0
End Function

'------------------------------------------------------------------------------
' POP rp | POP PSW
' Pops 2 bytes to register pair or A+flags for PSW.
' Errors (base 420):
'   420: missing operand
'   421: invalid register name
'------------------------------------------------------------------------------
Friend Function POP(ByVal op1) As Long
    Dim res As Long, sp As Long
    Dim registerRecH As clsDecRegisterState, registerRecL As clsDecRegisterState
    Dim decLow As Long, decHigh As Long
    Dim errorBase As Long: errorBase = 420
    Dim flagByte As Byte

    res = 0
    If op1 = "" Then SetError errorBase, "POP: Missing Operand: " & op1: POP = errorBase: Exit Function

    sp = pRegs("SP")
    Set registerRecL = pStack.clsPOP: sp = sp + 1
    Set registerRecH = pStack.clsPOP: sp = sp + 1
    decLow = registerRecL.value
    decHigh = registerRecH.value

    Select Case op1
        Case "B": SetReg "B", decHigh: SetReg "C", decLow
        Case "D": SetReg "D", decHigh: SetReg "E", decLow
        Case "H": SetReg "H", decHigh: SetReg "L", decLow
        Case "PSW"
            SetReg "A", decHigh
            flagByte = decLow And 255
            pFlags("Sign") = IIf((flagByte And 128) <> 0, 1, 0)
            pFlags("Zero") = IIf((flagByte And 64) <> 0, 1, 0)
            pFlags("AC") = IIf((flagByte And 16) <> 0, 1, 0)
            pFlags("Parity") = IIf((flagByte And 4) <> 0, 1, 0)
            pFlags("Flag") = 1
            pFlags("Carry") = IIf((flagByte And 1) <> 0, 1, 0)
            mUIFlagsDirty = True
        Case Else
            SetError errorBase + 1, "POP: Invalid Register: " & op1: POP = errorBase + 1: Exit Function
    End Select

    SetReg "SP", sp
    
    POP = res
End Function

'------------------------------------------------------------------------------
' PUSH rp | PUSH PSW
' Pushes register pair or A+flags to stack. For PSW, synthesizes flag byte with
' the 8080 reserved bit set to 1 (bit 1).
' Errors (base 430):
'   430: missing operand
'   431: invalid register name
'------------------------------------------------------------------------------
Public Function PUSH(ByVal op1) As Long
    Dim sp As Long
    Dim sp_high As String, sp_low As String
    Dim errorBase As Long: errorBase = 430
    Dim flagByte As Byte

    If op1 = "" Then SetError errorBase, "PUSH: Missing Operand: " & op1: PUSH = errorBase: Exit Function

    sp = pRegs("SP")
    sp_high = sp - 1
    sp = sp - 1
    sp_low = sp
    
    Select Case op1
        Case "B": pStack.clsPUSH sp_high, pRegs("B"), "B": pStack.clsPUSH sp_low, pRegs("C"), "C"
        Case "D": pStack.clsPUSH sp_high, pRegs("D"), "D": pStack.clsPUSH sp_low, pRegs("E"), "E"
        Case "H": pStack.clsPUSH sp_high, pRegs("H"), "H": pStack.clsPUSH sp_low, pRegs("L"), "L"
        Case "PSW"
            pStack.clsPUSH sp, pRegs("A"), "A"
            sp = sp - 1
            flagByte = 0
            If pFlags("Sign") = 1 Then flagByte = flagByte + 128
            If pFlags("Zero") = 1 Then flagByte = flagByte + 64
            If pFlags("AC") = 1 Then flagByte = flagByte + 16
            If pFlags("Parity") = 1 Then flagByte = flagByte + 4
            flagByte = flagByte + 2     ' reserved bit set
            If pFlags("Carry") = 1 Then flagByte = flagByte + 1
            
            pStack.clsPUSH sp, flagByte, "Flags"
        Case Else
            SetError errorBase + 1, "PUSH: Invalid Register: " & op1: PUSH = errorBase + 1: Exit Function
    End Select

    SetReg "SP", sp
    mUIStackDirty = True
    
    PUSH = 0
End Function

'------------------------------------------------------------------------------
' RET
' Pops 2-byte return address written by CALL_ and jumps back.
' Errors (base 460):
'   460: empty stack (no address)
'   461: stack top isn t a CALL frame
'------------------------------------------------------------------------------
Public Function RET() As Long
    Dim stackRec As clsDecRegisterState
    Dim Count As Long, newPC As Long, sp_dec As Long
    Dim retAddress As String, retAddress_dec As Long
    Dim line0Address As Long
    Dim errorBase As Long: errorBase = 460

    Count = pStack.Count
    If Count = 0 Then SetError errorBase, "RET: No Address on Stack": RET = errorBase: Exit Function

    Set stackRec = pStack.clsPeek
    If Left$(stackRec.RegisterName, 4) <> "CALL" Then SetError errorBase + 1, "RET: Invalid Address on Stack: " & stackRec.RegisterName: RET = errorBase + 1: Exit Function

    sp_dec = pRegs("SP")
    Set stackRec = pStack.clsPOP
    sp_dec = sp_dec + 1
    retAddress_dec = stackRec.value
    retAddress = FastHex(retAddress_dec)
    
    Set stackRec = pStack.clsPOP
    sp_dec = sp_dec + 1
    retAddress = FastHex(stackRec.value) & retAddress

    Me.SetReg "SP", sp_dec
    mUIStackDirty = True

    newPC = HexToDec(retAddress) - 1
    SetPC newPC

    RET = 0
End Function

' Evaluates jump conditions against flags
Private Function EvaluateCondition(ByVal opcode As String) As Boolean
    Select Case opcode
        Case "JZ":  EvaluateCondition = (pFlags("Zero") = 1)
        Case "JNZ": EvaluateCondition = (pFlags("Zero") = 0)
        Case "JC":  EvaluateCondition = (pFlags("Carry") = 1)
        Case "JNC": EvaluateCondition = (pFlags("Carry") = 0)
        Case "JM":  EvaluateCondition = (pFlags("Sign") = 1)
        Case "JP":  EvaluateCondition = (pFlags("Sign") = 0)
        Case "JPE": EvaluateCondition = (pFlags("Parity") = 1)
        Case "JPO": EvaluateCondition = (pFlags("Parity") = 0)
    End Select
End Function

Private Function CondTrue(ByVal cond As String) As Boolean
    Select Case cond
        Case "Z":  CondTrue = (pFlags("Zero") = 1)
        Case "NZ": CondTrue = (pFlags("Zero") = 0)
        Case "C":  CondTrue = (pFlags("Carry") = 1)
        Case "NC": CondTrue = (pFlags("Carry") = 0)
        Case "M":  CondTrue = (pFlags("Sign") = 1)
        Case "P":  CondTrue = (pFlags("Sign") = 0)
        Case "PE": CondTrue = (pFlags("Parity") = 1)
        Case "PO": CondTrue = (pFlags("Parity") = 0)
    End Select
End Function

'------------------------------------------------------------------------------
'                         Copilot generated additional opcodes
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
'                         Validated
'------------------------------------------------------------------------------
' --- ADC r (A = A + r + CY) ---
Public Function ADC(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 110
    Dim a As Long, b As Long, c As Long, sum As Long, result As Long
    Dim ac As Long

    If op1 = "" Then SetError errorBase, "ADC: Missing Operand": ADC = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "ADC: Invalid Register: " & op1: ADC = errorBase + 1: Exit Function

    a = pRegs("A") And 255
    b = pRegs(op1) And 255
    c = pFlags("Carry") And 1

    sum = a + b + c
    result = sum And 255

    SetCarry IIf(sum > 255, 1, 0)
    ac = IIf(((a And &HF) + (b And &HF) + c) > &HF, 1, 0)
    SetAC ac

    SetReg "A", result
    SetSign result: SetZero result: SetParity result
    ADC = 0
End Function

' --- ACI data (A = A + imm + CY) ---
' Validated
Public Function ACI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 100
    Dim a As Long, c As Long, sum As Long, result As Long, ac As Long, dec_op1 As Long
    Dim lbl As clsLabelRecord
    
    ' 1) Operand required
    If op1 = "" Then
        SetError errorBase, "ACI: Missing Operand"
        ACI = errorBase
        Exit Function
    End If

    ' 2) Allow EQU labels as immediate (like your MVI does)
    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then
        op1 = lbl.clsAddressHex  ' use the label's hex value/address
    End If

    ' 3) Validate immediate (8-bit)
    If Not IsValidHex(op1) Then
        SetError errorBase + 1, "ACI: Invalid Hex Immediate: " & op1
        ACI = errorBase + 1
        Exit Function
    End If
    
    dec_op1 = HexToDec(op1) And 255  ' force to 8-bit
    a = pRegs("A") And 255
    c = pFlags("Carry") And 1
    
    sum = a + dec_op1 + c
    result = sum And 255

    SetCarry IIf(sum > 255, 1, 0)
    ac = IIf(((a And &HF) + (dec_op1 And &HF) + c) > &HF, 1, 0)
    SetAC ac

    SetReg "A", result
    SetSign result
    SetZero result
    SetParity result
    ACI = 0
End Function

'------------------------------------------------------------------------------
'                         TBD
'------------------------------------------------------------------------------

' --- SUB r (A = A - r) ; CY=1 on borrow ---
Public Function SUB_(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 580
    Dim a As Long, b As Long, diff As Long, result As Long
    Dim borrow As Long, acBorrow As Long

    If op1 = "" Then SetError errorBase, "SUB: Missing Operand": SUB_ = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "SUB: Invalid Register: " & op1: SUB_ = errorBase + 1: Exit Function

    a = pRegs("A") And 255
    b = pRegs(op1) And 255

    borrow = IIf(a < b, 1, 0)
    acBorrow = IIf((a And &HF) < (b And &HF), 1, 0)

    diff = a - b
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow

    SetReg "A", result
    SetSign result: SetZero result: SetParity result
    SUB_ = 0
End Function

' --- SUI data (A = A - imm) ; CY=1 on borrow ---
Public Function SUI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 590
    Dim a As Long, b As Long, diff As Long, result As Long, dec_op1 As Long
    Dim borrow As Long, acBorrow As Long
    Dim lbl As clsLabelRecord

    ' 1) Operand required
    If op1 = "" Then
        SetError errorBase, "SUI: Missing Operand"
        SUI = errorBase
        Exit Function
    End If

    ' 2) Allow EQU labels as immediate (like your MVI does)
    Set lbl = pLabels.GetLabel(op1)
    If Not lbl Is Nothing Then
        op1 = lbl.clsAddressHex  ' use the label's hex value/address
    End If

    ' 3) Validate immediate (8-bit)
    If Not IsValidHex(op1) Then
        SetError errorBase + 1, "SUI: Invalid Hex Immediate: " & op1
        SUI = errorBase + 1
        Exit Function
    End If
    
    dec_op1 = HexToDec(op1) And 255  ' force to 8-bit
    a = pRegs("A") And 255
    b = dec_op1 And 255

    borrow = IIf(a < b, 1, 0)
    acBorrow = IIf((a And &HF) < (b And &HF), 1, 0)

    diff = a - b
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow

    SetReg "A", result
    SetSign result: SetZero result: SetParity result
    SUI = 0
End Function

' --- SBB r (A = A - r - CY) ; CY=1 on borrow ---
Public Function SBB(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 500
    Dim a As Long, b As Long, c As Long, subtr As Long
    Dim diff As Long, result As Long
    Dim borrow As Long, acBorrow As Long

    If op1 = "" Then SetError errorBase, "SBB: Missing Operand": SBB = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "SBB: Invalid Register: " & op1: SBB = errorBase + 1: Exit Function

    a = pRegs("A") And 255
    b = pRegs(op1) And 255
    c = pFlags("Carry") And 1
    subtr = b + c

    borrow = IIf(a < subtr, 1, 0)
    acBorrow = IIf((a And &HF) < ((b And &HF) + c), 1, 0)

    diff = a - subtr
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow

    SetReg "A", result
    SetSign result: SetZero result: SetParity result
    SBB = 0
End Function

' --- SBI data (A = A - imm - CY) ; CY=1 on borrow ---
Public Function SBI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 510
    Dim imm As Variant, a As Long, b As Long, c As Long, subtr As Long
    Dim diff As Long, result As Long
    Dim borrow As Long, acBorrow As Long


    a = pRegs("A") And 255
    b = CLng(imm) And 255
    c = pFlags("Carry") And 1
    subtr = b + c

    borrow = IIf(a < subtr, 1, 0)
    acBorrow = IIf((a And &HF) < ((b And &HF) + c), 1, 0)

    diff = a - subtr
    result = diff And 255

    SetCarry borrow
    SetAC acBorrow

    SetReg "A", result
    SetSign result: SetZero result: SetParity result
    SBI = 0
End Function

' --- XRA r (A = A XOR r) ; clears CY and AC; sets S/Z/P ---
Public Function XRA(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 610
    Dim a As Long, b As Long, result As Long

    If op1 = "" Then SetError errorBase, "XRA: Missing Operand": XRA = errorBase: Exit Function
    If Not pRegs.exists(op1) Then SetError errorBase + 1, "XRA: Invalid Register: " & op1: XRA = errorBase + 1: Exit Function

    a = pRegs("A") And 255
    b = pRegs(op1) And 255
    result = (a Xor b) And 255

    SetReg "A", result
    SetCarry 0
    SetAC 0
    SetSign result: SetZero result: SetParity result
    XRA = 0
End Function

' --- XRI data (A = A XOR imm) ; clears CY and AC; sets S/Z/P ---
Public Function XRI(ByVal op1 As String) As Long
    Dim errorBase As Long: errorBase = 620
    Dim imm As Variant, a As Long, result As Long


    a = pRegs("A") And 255
    result = (a Xor (CLng(imm) And 255)) And 255

    SetReg "A", result
    SetCarry 0
    SetAC 0
    SetSign result: SetZero result: SetParity result
    XRI = 0
End Function

' --- RLC/RRC/RAL/RAR (only CY affected, other flags unchanged) ---
Public Function RLC() As Long
    Dim a As Long, msb As Long, result As Long
    a = pRegs("A") And 255
    msb = IIf((a And &H80) <> 0, 1, 0)
    result = ((a * 2) And 255) Or msb
    SetReg "A", result
    SetCarry msb
    RLC = 0
End Function

Public Function RRC() As Long
    Dim a As Long, lsb As Long, result As Long
    a = pRegs("A") And 255
    lsb = a And 1
    result = ((a \ 2) And 127) Or (lsb * 128)
    SetReg "A", result
    SetCarry lsb
    RRC = 0
End Function

Public Function RAL() As Long
    Dim a As Long, msb As Long, cy As Long, result As Long
    a = pRegs("A") And 255
    cy = pFlags("Carry") And 1
    msb = IIf((a And &H80) <> 0, 1, 0)
    result = ((a * 2) And 255) Or cy
    SetReg "A", result
    SetCarry msb
    RAL = 0
End Function

Public Function RAR() As Long
    Dim a As Long, lsb As Long, cy As Long, result As Long
    a = pRegs("A") And 255
    cy = pFlags("Carry") And 1
    lsb = a And 1
    result = ((a \ 2) And 127) Or (cy * 128)
    SetReg "A", result
    SetCarry lsb
    RAR = 0
End Function

' --- STC/CMC/CMA ---
Public Function STC() As Long
    SetCarry 1
    STC = 0
End Function

Public Function CMC() As Long
    SetCarry (1 - (pFlags("Carry") And 1))
    CMC = 0
End Function

Public Function CMA() As Long
    Dim a As Long
    a = pRegs("A") And 255
    SetReg "A", ((a Xor &HFF) And 255)
    ' Flags unaffected
    CMA = 0
End Function

' --- INX/DCX rp (no flags) ---
Public Function INX(ByVal rp As String) As Long
    Dim errorBase As Long: errorBase = 290
    Dim v As Variant
'    v = GetPairValue(rp, errorBase, "INX")
'    If IsEmpty(v) Then INX = errorBase: Exit Function
'    SetPairValue rp, (CLng(v) + 1) And &HFFFF&
    INX = 0
End Function

Public Function DCX(ByVal rp As String) As Long
    Dim errorBase As Long: errorBase = 240
    Dim v As Variant
'    v = GetPairValue(rp, errorBase, "DCX")
'    If IsEmpty(v) Then DCX = errorBase: Exit Function
'    SetPairValue rp, (CLng(v) - 1) And &HFFFF&
    DCX = 0
End Function

' --- DAD rp (HL = HL + rp) ; sets CY only ---
Public Function DAD(ByVal rp As String) As Long
    Dim errorBase As Long: errorBase = 220
    Dim hl As Long, addv As Variant, sum As Long

'    addv = GetPairValue(rp, errorBase, "DAD")
'    If IsEmpty(addv) Then DAD = errorBase: Exit Function

'    hl = ((pRegs("H") And 255) * 256&) + (pRegs("L") And 255)
'    sum = hl + CLng(addv)

'    SetCarry IIf(sum > &HFFFF&, 1, 0)
'    sum = sum And &HFFFF&

'    SetReg "H", (sum \ 256&) And 255
'    SetReg "L", sum And 255
    DAD = 0
End Function

' --- DAA (BCD adjust after add/adc) ---
Public Function DAA() As Long
    Dim errorBase As Long: errorBase = 210
    Dim a As Long, add As Long
    Dim cyIn As Long, cyOut As Long
    Dim lowAdj As Boolean
    Dim result As Long

    a = pRegs("A") And 255
    cyIn = pFlags("Carry") And 1

    add = 0
    lowAdj = False

    If ((a And &HF) > 9) Or (pFlags("AC") = 1) Then
        add = add + &H6
        lowAdj = True
    End If

    If (a > &H99) Or (cyIn = 1) Then
        add = add + &H60
    End If

    result = a + add

    cyOut = IIf((result > 255) Or (a > &H99) Or (cyIn = 1 And (add And &H60) <> 0), 1, 0)
    SetCarry cyOut
    SetAC IIf(lowAdj, 1, 0)

    result = result And 255
    SetReg "A", result
    SetSign result: SetZero result: SetParity result

    DAA = 0
End Function

' --- XCHG (swap DE <-> HL) ---
Public Function XCHG() As Long
    Dim d As Long, e As Long, h As Long, l As Long
    d = pRegs("D"): e = pRegs("E")
    h = pRegs("H"): l = pRegs("L")
    SetReg "D", h: SetReg "E", l
    SetReg "H", d: SetReg "L", e
    XCHG = 0
End Function

' --- SPHL (SP = HL) ---
Public Function SPHL() As Long
    Dim hl As Long
    hl = ((pRegs("H") And 255) * 256&) + (pRegs("L") And 255)
    SetReg "SP", hl And &HFFFF&
    mUIStackDirty = True
    SPHL = 0
End Function

' --- PCHL (PC = HL) ; loop will IncPC, so set PC to HL-1 ---
Public Function PCHL() As Long
    Dim hl As Long
    hl = ((pRegs("H") And 255) * 256&) + (pRegs("L") And 255)
    SetPC (hl - 1)
    PCHL = 0
End Function

' --- Conditional CALL / RET (no memory beyond stack) ---
Public Function CCOND(ByVal cond As String, ByVal target As String) As Long
    If CondTrue(cond) Then
        CCOND = CALL_(target)
    Else
        CCOND = 0
    End If
End Function

Public Function RCOND(ByVal cond As String) As Long
    If CondTrue(cond) Then
        RCOND = RET()
    Else
        RCOND = 0
    End If
End Function
'==============================================================================
'                         Copilot Helper Utilities
'==============================================================================
'==========================
' clsDecCPU Helpers (NEW)
'==========================
Private Function ResolveImm8(ByVal token As String, ByVal errorBase As Long, ByVal opname As String) As Variant
    Dim lbl As clsLabelRecord

    If token = "" Then
        SetError errorBase, opname & ": Missing Operand"
        ResolveImm8 = Empty
        Exit Function
    End If

    Set lbl = pLabels.GetLabel(token)
    If Not lbl Is Nothing Then token = lbl.clsAddressHex

    If Not IsValidHex(token) Then
        SetError errorBase + 1, opname & ": Invalid Hex Immediate: " & token
        ResolveImm8 = Empty
        Exit Function
    End If

    ResolveImm8 = (HexToDec(token) And 255)
End Function

Private Function GetPairValue(ByVal rp As String, ByVal errorBase As Long, ByVal opname As String) As Variant
    Dim v As Long
    Select Case rp
        Case "B": v = ((pRegs("B") And 255) * 256&) + (pRegs("C") And 255)
        Case "D": v = ((pRegs("D") And 255) * 256&) + (pRegs("E") And 255)
        Case "H": v = ((pRegs("H") And 255) * 256&) + (pRegs("L") And 255)
        Case "SP": v = (pRegs("SP") And &HFFFF&)
        Case Else
            SetError errorBase + 1, opname & ": Invalid Register Pair: " & rp
            GetPairValue = Empty
            Exit Function
    End Select
    GetPairValue = (v And &HFFFF&)
End Function

Private Sub SetPairValue(ByVal rp As String, ByVal v As Long)
    v = v And &HFFFF&
    Select Case rp
        Case "B"
            SetReg "B", (v \ 256&) And 255
            SetReg "C", v And 255
        Case "D"
            SetReg "D", (v \ 256&) And 255
            SetReg "E", v And 255
        Case "H"
            SetReg "H", (v \ 256&) And 255
            SetReg "L", v And 255
        Case "SP"
            SetReg "SP", v
            mUIStackDirty = True
    End Select
End Sub


'==============================================================================
'                         Register / Flag Utilities
'==============================================================================

Public Property Get Reg(ByVal name As String) As Variant
    If pRegs.exists(name) Then Reg = pRegs(name) Else Reg = 0
End Property

Public Property Let Reg(ByVal name As String, ByVal value As Variant)
    If pRegs.exists(name) Then pRegs(name) = value
End Property
Public Property Get Registers() As Variant
    Registers = pRegs.Keys
End Property
Public Property Get Flag(ByVal name As String) As Long
    If pFlags.exists(name) Then Flag = pFlags(name) Else Flag = 0
End Property
Public Property Get Flags() As Variant
    Flags = pFlags.Keys
End Property


' Load registers from sheet (for continuation runs)
Public Sub LDARegs()
    Dim key As Variant, strReg As String
    For Each key In pRegs.Keys
        If key = "PC" Or key = "SP" Then
            strReg = key
        Else
            strReg = "R_" & key
        End If
        pRegs(key) = HexToDec(Range(strReg).value)
    Next key
End Sub

' Reset register *display* cells (not used to clear internal state here)
Public Sub STARegs()
    Dim key As Variant, strReg As String
    For Each key In pRegs.Keys
        If key <> "PC" And key <> "SP" Then
            strReg = "R_" & key
            Range(strReg).value = FastHex(pRegs("key"))
        End If
    Next key
End Sub

' Centralized error setter (writes Error / errMessage on sheet)
Private Sub SetError(ByVal errcode As Long, ByVal errString As String)
    Dim errMessage As String
    If errString Like "*Halt*" Then errMessage = errString Else errMessage = "Error: " & errcode & " - " & errString
    errMessage = errMessage & " at line " & Reg("PC")
    Range("Error").value = errcode
    Range("errMessage") = errMessage
End Sub

' Valid hex: 2 or 4 digits (0-9A-F); pads 1/3 to 2/4 for convenience
Public Function IsValidHex(ByVal hexValue As String) As Boolean
    Dim length As Long
    length = Len(hexValue)
    If length = 1 Or length = 3 Then hexValue = "0" & hexValue: length = length + 1
    If length <> 2 And length <> 4 Then IsValidHex = False: Exit Function
    If hexValue Like "*[!0-9a-fA-F]*" Then IsValidHex = False Else IsValidHex = True
End Function

' Increment PC and update sheet (unless deferred)
Public Function IncPC() As Long
    pPC_dec = pPC_dec + 1
    pRegs("PC") = pPC_dec
    IncPC = pPC_dec
End Function

' Set PC to absolute decimal address and update sheet (unless deferred)
Public Function SetPC(ByVal address As Long)
    pPC_dec = address
    pRegs("PC") = pPC_dec
    mUIRegsDirty = True
    SetPC = pPC_dec
End Function

'------------------------------------------------------------------------------
' SetParity (fast via LUT): sets Parity=1 for even parity as on 8080
'------------------------------------------------------------------------------
Public Function ParityCalc(ByVal bits As Byte) As Long
    Static parity(0 To 255) As Byte
    Static init As Boolean
    Dim i As Long, b As Long, c As Long
    If Not init Then
        For i = 0 To 255
            b = i: c = 0
            Do While b
                c = c Xor (b And 1)
                b = b \ 2
            Loop
            ' 8080 parity flag: 1 for even parity
            parity(i) = IIf(c = 0, 1, 0)
        Next
        init = True
    End If
    ParityCalc = parity(bits)
End Function
Private Function SetParity(ByVal bits As Byte) As Long
    pFlags("Parity") = ParityCalc(bits)
    mUIFlagsDirty = True
    SetParity = pFlags("Parity")
End Function
Private Function SetSign(bits As Long) As Long
    Dim sign As Long
    sign = IIf((bits And 128) > 0, 1, 0)
    pFlags("Sign") = sign
    mUIFlagsDirty = True
    SetSign = sign
End Function
Private Function SetAC(bits As Long) As Long
    pFlags("AC") = bits And 1
    mUIFlagsDirty = True
    SetAC = bits
End Function
Private Function SetCarry(bits As Long) As Long
    pFlags("Carry") = bits And 1
    mUIFlagsDirty = True
    SetCarry = bits
End Function
Public Function SetZero(result As Long) As Long
    pFlags("Zero") = IIf(result = 0, 1, 0)
    mUIFlagsDirty = True
    SetZero = pFlags("Zero")
End Function

' SetReg always updates internal state; paints UI only if not deferred.
Public Function SetReg(ByVal register As String, ByVal value As Long)
    pRegs(register) = value
    mUIRegsDirty = True
    SetReg = value
End Function

'==============================================================================
'                     Console Procedure Shims (CALL targets)
'==============================================================================

' PRTN
' If op2 provided, prints literal; otherwise resolves HL to a data label and
' prints its clsData. Optional CR/LF and space prefix handled by flags.
Public Function PRTN(Optional ByVal op2 As String, _
                     Optional ByVal crlf As Boolean = False, _
                     Optional ByVal prtSpace As Boolean = False) As Long
    Dim errorBase As Long: errorBase = 425
    Dim record As clsLabelRecord
    Dim address As String
    Dim address_high As String
    Dim address_low As String

    If Len(op2) > 0 Then
        ConsolePrint op2, crlf, prtSpace
        PRTN = 0
        Exit Function
    End If

    ' Resolve address in HL
    address_high = Right("00" & FastHex(pRegs("H")), 2)
    address_low = Right("00" & FastHex(pRegs("L")), 2)
    address = address_high & address_low
    Set record = pLabels.GetByXref(address)
    If record Is Nothing Then
        SetError errorBase, "PRTN: Missing Label for Address: " & address
        PRTN = errorBase
        Exit Function
    End If

    ConsolePrint record.clsData, crlf, prtSpace
    PRTN = 0
End Function

Public Function PRTNS(Optional ByVal op2 As String) As Long
    ' space + text (no newline)
    PRTNS = PRTN(op2, False, True)
End Function

Public Function PRTCRLF(Optional ByVal op2 As String) As Long
    ' newline, no leading space
    PRTCRLF = PRTN(op2, True, False)
End Function

Public Function PRTCRLFS(Optional ByVal op2 As String) As Long
    ' newline + leading space
    PRTCRLFS = PRTN(op2, True, True)
End Function
Public Property Get StackDirty() As Boolean
    StackDirty = mUIStackDirty
End Property

Public Property Let StackDirty(ByVal dirty As Boolean)
    mUIStackDirty = dirty
End Property
Public Property Get FlagsDirty() As Boolean
    FlagsDirty = mUIFlagsDirty
End Property
Public Property Let FlagsDirty(ByVal dirty As Boolean)
    mUIFlagsDirty = dirty
End Property
Public Property Get RegistersDirty() As Boolean
    RegistersDirty = mUIRegsDirty
End Property
Public Property Let RegistersDirty(ByVal dirty As Boolean)
    mUIRegsDirty = dirty
End Property
Public Function RefreshStack(ByVal refresh) As Boolean
    RefreshStack = pStack.ShowStack(refresh)
End Function

'================================================================================
' Class:        clsDecCPU
'================================================================================



''' Component: modGlobals
Option Explicit
'================================================================================
' Module:       modGlobals
'================================================================================

Private pCPU As clsDecCPU ' actual object reference
Private HexTable(0 To 255) As String
Private mIHexIintialized As Boolean
' --- Console buffer (authoritative text for tests) ---
Private gConsoleBuffer As String
' Tracks whether the console form is open
Public mConsoleOpen As Boolean

'------------------------------------------------------------------------------
' gCPU
' Returns the shared CPU instance, creating it if necessary.
'------------------------------------------------------------------------------
Public Property Get gDecCPU() As clsDecCPU
    If pCPU Is Nothing Then
        Set pCPU = New clsDecCPU
    End If
    Set gDecCPU = pCPU
End Property

'------------------------------------------------------------------------------
' ResetCPU
' Discards the current instance; next gCPU() call will re-create it.
'------------------------------------------------------------------------------
Public Sub ResetDecCPU()
    Set pCPU = Nothing
End Sub

Public Sub InitHexTable()
    Dim i As Long ' Use Long to avoid overflow during loop
    For i = 0 To 255
        ' IMPORTANT: Use the built-in Hex$ function here, NOT FastHex
        HexTable(i) = Right$("0" & hex$(i), 2)
    Next i
    mIHexIintialized = True
End Sub
Public Function FastHex(ByVal value As Long) As String
    If Not mIHexIintialized Then InitHexTable
    
    ' Handle values as 16-bit if they exceed 255
    ' This covers PC, SP, and address operands automatically
    If value > 255 Then
        FastHex = HexTable(value \ 256) & HexTable(value Mod 256)
    ElseIf value < 0 Then
        ' Handle potential negative overflows if any
        FastHex = "0000"
    Else
        ' Standard 8-bit register (A, B, C, etc.)
        FastHex = HexTable(value)
    End If
End Function

'------------------------------------------------------------------------------
' Console utilities (modeless)
'------------------------------------------------------------------------------
Public Sub ConsolePrint(ByVal text As String, _
                        Optional ByVal crlf As Boolean = True, _
                        Optional ByVal prtSpace As Boolean = False)
    ' 1) Always update the authoritative buffer synchronously
    ConsoleBuffer_Append text, crlf, prtSpace

    ' 2) Optionally update the UI (unchanged behavior)
    'If Not mConsoleOpen Then ShowConsole
    If crlf Then
        usrForm.ConPrtLn text, prtSpace
    Else
        usrForm.ConPrt text, prtSpace
    End If
End Sub

Public Sub ClearConsole()
    usrForm.ClearConsole
End Sub

Public Sub ShowConsole()
    usrForm.Show vbModeless
    mConsoleOpen = True
End Sub

Public Sub ConsoleBuffer_Clear()
    gConsoleBuffer = vbNullString
End Sub

Public Sub ConsoleBuffer_Append(ByVal s As String, Optional ByVal addCrlf As Boolean = False, Optional ByVal addLeadingSpace As Boolean = False)
    If addLeadingSpace And Len(gConsoleBuffer) > 0 Then gConsoleBuffer = gConsoleBuffer & " "
    gConsoleBuffer = gConsoleBuffer & s
    If addCrlf Then gConsoleBuffer = gConsoleBuffer & vbCrLf
End Sub

Public Function ConsoleBuffer_Text() As String
    ConsoleBuffer_Text = gConsoleBuffer
End Function

Public Sub SelectEngine()
    decExecute
End Sub

'================================================================================
' Module:       modGlobals
'================================================================================


''' Component: clsDecRegisterState
Option Explicit
'================================================================================
' Class:        clsDecRegisterState
' Purpose:      Lightweight record for decimal based stack entries:
'               - MemoryAddress: long
'               - Value:        dec as pushed
'               - RegisterName: label for provenance (e.g., "CALL X", "B", "Flags")
'
' Notes:        No logic; public fields used by clsStack and clsCPU.
' Source:       Stable snapshot (2026-02-12 18:38)
'================================================================================

Public MemoryAddress As Long
Public value As Long
Public RegisterName As String

'================================================================================
' Class:        clsDecRegisterState
'================================================================================



''' Component: clsDecStack
Option Explicit
'================================================================================
' Class:        clsDecStack
' Purpose:      Simple LIFO stack of clsRegisterState items for the emulator.
'               - PUSH/POP/PEEK operations over an internal dynamic array
'               - ShowStack renders the visible stack view on the CPU sheet
'
'================================================================================

Private m_Items() As clsDecRegisterState
Private m_Count As Long

Private Sub Class_Initialize()
    m_Count = 0
    ReDim m_Items(0)
End Sub

'------------------------------------------------------------------------------
' ShowStack
' Renders the current stack (top at row 1) into named ranges on the CPU sheet.
' Skips redraw during headless runs unless force=True.
'------------------------------------------------------------------------------
Public Function ShowStack(Optional ByVal refresh As Boolean = False) As Boolean
    If Not refresh Then
        ShowStack = False
        Exit Function
    End If
    Dim i As Long, detail As Long
    Range("StackDetails").ClearContents

    If m_Count > 0 Then
        For i = 1 To m_Count
            detail = m_Count - i + 1
            Range("stackView").Offset(i - 1, 1).value = FastHex(m_Items(detail).MemoryAddress)
            Range("stackView").Offset(i - 1, 2).value = Right$("00" & FastHex(m_Items(detail).value), 2) & "H"
            Range("stackView").Offset(i - 1, 3).value = m_Items(detail).RegisterName
        Next
    End If
    ShowStack = True
End Function

'------------------------------------------------------------------------------
' clsPUSH
' Pushes a new item with (address, value, register name) onto the stack.
'------------------------------------------------------------------------------
Public Sub clsPUSH(ByVal Addr As Long, ByVal Val As Long, ByVal Reg As String)
    Dim newItem As clsDecRegisterState
    Set newItem = New clsDecRegisterState

    newItem.MemoryAddress = Addr
    newItem.value = Val
    newItem.RegisterName = Reg

    m_Count = m_Count + 1
    If m_Count = 1 Then
        ReDim m_Items(1 To 1)
    Else
        ReDim Preserve m_Items(1 To m_Count)
    End If

    Set m_Items(m_Count) = newItem
End Sub

'------------------------------------------------------------------------------
' clsPOP
' Pops the top item. Raises a descriptive error if underflow occurs.
'------------------------------------------------------------------------------
Public Function clsPOP() As clsDecRegisterState
    If m_Count > 0 Then
        Set clsPOP = m_Items(m_Count)
        m_Count = m_Count - 1
        If m_Count > 0 Then
            ReDim Preserve m_Items(1 To m_Count)
        Else
            ReDim m_Items(0)
        End If
    Else
        Err.Raise vbObjectError + 513, "clsStack", "Stack Underflow: No items to pop."
    End If
End Function

'------------------------------------------------------------------------------
' clsPeek
' Returns the top item without removing it. Nothing if empty.
'------------------------------------------------------------------------------
Public Function clsPeek() As clsDecRegisterState
    If m_Count > 0 Then
        Set clsPeek = m_Items(m_Count)
    Else
        Set clsPeek = Nothing
    End If
End Function

'------------------------------------------------------------------------------
' Count
' Returns the number of items on the stack.
'------------------------------------------------------------------------------
Public Property Get Count() As Long
    Count = m_Count
End Property

'================================================================================
' Class:        clsDecStack
'================================================================================



''' Component: decAssemble
Option Explicit
'================================================================================
' Module:       decAssemble
' Purpose:      Execution harness for the Excel/VBA Intel 8080 emulator.
'               - Initializes/rehydrates CPU and memory
'               - Selection-free, headless-aware main loop
'               - Routes opcodes to clsCPU
'               - Console helpers (modeless output form)
'
' Notes:        This is documentation/reformat only. No functional changes.
' Source:       Stable snapshot (2026-02-12 18:38)  ? Export reference.
'================================================================================


'------------------------------------------------------------------------------
' Execute
' Entry point for a run. Honours "Reset" and "Step" (headless) flags on the CPU
' sheet. Bulk-reads instruction columns to arrays for performance. Routes each
' opcode to RunOpcode (which dispatches into clsCPU).
'
' Sheet bindings (named ranges expected on "CPU"):
'   Start_pc_dec, pc_dec, Reset, Error, errMessage
'   MemStart, MemSize, MemEnd
'   ofs_opcode, ofs_op1, ofs_op2, ofs_rowstat, ofs_label
'   Line0_dec (decimal first row of memory/instruction grid), StackStart, StackDetails,
'   consoleOut, Step
'------------------------------------------------------------------------------
Public Sub decExecute()
    Dim pc_dec As Long
    Dim opcode As String
    Dim op1 As String, op2 As String, label As String
    Dim ofs_opcode As Long, ofs_op1 As Long, ofs_op2 As Long, ofs_rowstat As Long, ofs_label As Long
    Dim Reset As Long, errcode As Long
    Dim rowStat As String
    Dim memStart As Long, memSize As Long, memEnd As Long
    Dim myCpu As clsDecCPU
    Dim headless As Boolean
    Dim prevCalc As XlCalculation
    Dim debugMode As Boolean
    Dim stepMode As Boolean
    Dim stepTaken As Boolean: stepTaken = False

    ' ========= Initialization =========
    InitHexTable
    ofs_opcode = Range("ofs_opcode").value
    ofs_op1 = Range("ofs_op1").value
    ofs_op2 = Range("ofs_op2").value
    ofs_rowstat = Range("ofs_rowstat").value
    ofs_label = Range("ofs_label").value
    debugMode = Range("Debug").value = 1
    stepMode = Range("Step").value = 1

    Reset = Range("Reset").value
    errcode = 0
    Range("Error").value = 0
    Range("errMessage").value = ""

    memStart = HexToDec(Range("MemStart").value)
    memSize = HexToDec(Range("MemSize").value)
    memEnd = memStart + memSize

    Set myCpu = gDecCPU

    ' Fresh Run
    If Reset = 1 Then
        ResetDecCPU
        Set myCpu = gDecCPU
        mConsoleOpen = False

        pc_dec = CLng(Range("Line0_dec").value)
        myCpu.SetPC pc_dec
        myCpu.Reg("SP") = memEnd
        Range("StackStart").value = FastHex(myCpu.Reg("SP"))

        Range("Mem").ClearContents
        Range("StackDetails").ClearContents
        Range("consoleOut").value = ""
    End If

    ' ========= Headless toggle =========
    headless = Not stepMode
    If headless Then
        Application.ScreenUpdating = False
        Application.EnableEvents = False
        prevCalc = Application.Calculation
        Application.Calculation = xlCalculationManual
    End If

    ' ========= Selection-free main loop with bulk reads =========
    Dim base As Range, line0_dec As Long
    Set base = Range("Line0_dec")
    line0_dec = CLng(base.value) ' Dec Line at Line0 (baseline)

    ' Number of rows to preload (MemStart..MemEnd)
    Dim countRows As Long
    countRows = (memEnd - memStart) + 1
    If countRows < 1 Then countRows = 1

    ' Load ONLY the columns we need into arrays
    Dim arrOpcode As Variant, arrRowStat As Variant
    Dim arrOp1 As Variant, arrOp2 As Variant, arrLabel As Variant

    arrOpcode = base.Offset(0, ofs_opcode).Resize(countRows, 1).value
    arrRowStat = base.Offset(0, ofs_rowstat).Resize(countRows, 1).value
    arrOp1 = base.Offset(0, ofs_op1).Resize(countRows, 1).value
    arrOp2 = base.Offset(0, ofs_op2).Resize(countRows, 1).value
    arrLabel = base.Offset(0, ofs_label).Resize(countRows, 1).value

    Dim ubRows_Opcode As Long, ubRows_RowStat As Long
    ubRows_Opcode = UBound(arrOpcode, 1)
    ubRows_RowStat = UBound(arrRowStat, 1)

    ' Optional one-time normalization for the hot loop.  all input trimed and set to 0 except for op2 since this can contain a string
    Const NormalizeInputs As Boolean = True
    If NormalizeInputs Then
        Dim idxN As Long
        For idxN = 1 To countRows
            If Not IsEmpty(arrOpcode(idxN, 1)) Then arrOpcode(idxN, 1) = Trim$(UCase$(CStr(arrOpcode(idxN, 1))))
            If Not IsEmpty(arrRowStat(idxN, 1)) Then arrRowStat(idxN, 1) = Trim$(UCase$(CStr(arrRowStat(idxN, 1))))
            If Not IsEmpty(arrOp1(idxN, 1)) Then arrOp1(idxN, 1) = Trim$(UCase$(CStr(arrOp1(idxN, 1))))
            If Not IsEmpty(arrOp2(idxN, 1)) Then arrOp2(idxN, 1) = Trim$(CStr(arrOp2(idxN, 1)))
            If Not IsEmpty(arrLabel(idxN, 1)) Then arrLabel(idxN, 1) = Trim$(UCase$(CStr(arrLabel(idxN, 1))))
        Next idxN
    End If

    ' Compute starting row index from pc_dec (hex text in clsCPU)
    Dim rowIdx As Long
    
    rowIdx = pc_dec - line0_dec

    ' Bounds before first read
    If rowIdx < 0 Or rowIdx >= ubRows_Opcode Then
        errcode = -200  ' END-like termination
        GoTo ExecFinalize
    End If

    ' First opcode from array
    opcode = CStr(arrOpcode(rowIdx + 1, 1))

    ' Prepare Range row for EQU label resolution
    Dim curRow As Range
    Set curRow = base.Offset(rowIdx, 0)

    ' ---- Throttle state (baseline 250ms) ----
    Dim instrCount As Long: instrCount = 0
    Dim nextPaint As Double: nextPaint = Timer + 0.25
    'If headless Then DoEvents

    Do While errcode = 0 And pc_dec <= memEnd And (Not stepMode Or (stepMode And Not stepTaken))
        ' Read operands / row status from arrays
        op1 = CStr(arrOp1(rowIdx + 1, 1))
        op2 = CStr(arrOp2(rowIdx + 1, 1))
        label = CStr(arrLabel(rowIdx + 1, 1))
        If op2 <> "EQU" Then
            op2 = UCase$(op2)
        End If

        If rowIdx >= 0 And rowIdx < ubRows_RowStat Then
            rowStat = CStr(arrRowStat(rowIdx + 1, 1))
        Else
            rowStat = Trim$(UCase$(CStr(curRow.Offset(0, ofs_rowstat).value)))
        End If

        ' Skip compiled rows (RowStat="C") and blanks
        If rowStat <> "C" And opcode <> "" Then
            If debugMode Then
                RefreshFlags myCpu
                RefreshRegisters myCpu
                myCpu.RefreshStack (True)
                Application.Calculate
                Debug.Assert Not debugMode
            End If
            errcode = myCpu.RunOpcode(opcode, op1, op2, label)
            If errcode <> 0 Then
                ' -9999 = Invalid opcode (consistent with clsCPU errors)
                If errcode = -9999 Then
                    Range("Error").value = errcode
                    Range("errMessage").value = "Error: Invalid OpCode: " & opcode & " at Line " & pc_dec
                End If
            End If
        End If

        ' Throttled repaint during headless runs (console progress)
        instrCount = instrCount + 1
        If headless Then
            If Timer >= nextPaint Then
                'DoEvents
                nextPaint = Timer + 0.25
            End If
        End If

        ' Advance pc_dec and compute next row
        pc_dec = myCpu.IncPC()
        rowIdx = pc_dec - line0_dec
        If rowIdx < 0 Or rowIdx >= ubRows_Opcode Then Exit Do

        ' Next opcode from array
        opcode = CStr(arrOpcode(rowIdx + 1, 1))

        ' Keep Range row current for EQU
        Set curRow = base.Offset(rowIdx, 0)
        ' (RowStat fetched at top of next iteration)
        If Not headless Then
            If myCpu.RegistersDirty Then
                RefreshRegisters myCpu
                myCpu.RegistersDirty = False
            End If
            If myCpu.FlagsDirty Then
                RefreshFlags myCpu
                myCpu.FlagsDirty = False
            End If
            If myCpu.StackDirty Then
                myCpu.RefreshStack True
                myCpu.FlagsDirty = False
            End If
        End If
        stepTaken = True
    Loop

ExecFinalize:
    ' ========= Finalization =========
    If headless Then
        Application.Calculation = prevCalc
        Application.EnableEvents = True
        Application.ScreenUpdating = True
        RefreshRegisters myCpu
        RefreshFlags myCpu
        myCpu.RefreshStack (True)
        Application.StatusBar = False
        Range("consoleText") = usrForm.tbConsole.value
    End If

    If Range("Error").value = 0 Or Range("Error").value = -200 Then
        Range("errMessage") = "Execution Complete"
    End If
End Sub

' UI updates
Public Function RefreshRegisters(ByRef myCpu As clsDecCPU) As Integer
    Dim key As Variant
    Dim rangeName As String
    For Each key In myCpu.Registers
        If InStr("ABCDEHL", key) Then
            rangeName = "R_"
        Else
            rangeName = ""
        End If
        rangeName = rangeName & CStr(key)
        Range(rangeName).value = FastHex(myCpu.Reg(key))
    Next
    myCpu.RegistersDirty = False
End Function
Public Function RefreshFlags(ByRef myCpu As clsDecCPU) As Integer
    Dim key As Variant
    Dim rangeName As String
    For Each key In myCpu.Flags
        Range(CStr(key)).value = myCpu.Flag(key)
    Next
    myCpu.FlagsDirty = False
End Function

'------------------------------------------------------------------------------
' HEX2ASCII
' Returns '.' for non-printables and '?' for invalid hex.
'------------------------------------------------------------------------------
Public Function HEX2ASCII(ByVal hexRange As Variant) As String
    Dim hexVal As String
    Dim decVal As Integer

    If IsEmpty(hexRange) Or hexRange = "" Then
        HEX2ASCII = ""
        Exit Function
    End If

    hexVal = CStr(hexRange)
    On Error Resume Next
    decVal = Application.WorksheetFunction.Hex2Dec(hexVal)
    If Err.Number <> 0 Then
        HEX2ASCII = "?"
        Exit Function
    End If
    On Error GoTo 0

    If decVal >= 32 And decVal <= 126 Then
        HEX2ASCII = Chr(decVal)
    Else
        HEX2ASCII = "."
    End If
End Function

'------------------------------------------------------------------------------
' HexToDec
' Safe hex string -> long (uses &H prefix trick)
'------------------------------------------------------------------------------
Public Function HexToDec(ByVal op1 As String) As Long
    HexToDec = Val("&H" & op1)
End Function


'------------------------------------------------------------------------------
' ResetRegisters
' Clears sheet register display cells (not CPU object) for A..L, PC, SP view.
'------------------------------------------------------------------------------
Public Sub ResetRegisters()
    Dim i As Integer
    For i = 0 To 8
        Range("Registers").Offset(i, 2).value = 0
    Next i
End Sub


'================================================================================
' Module:       decAssemble
'================================================================================






